{"ast":null,"code":"import { ref, set, get, remove, serverTimestamp } from \"firebase/database\";\nimport { rtdb } from \"../firebase/config\";\n\n// Reference to faces in Firebase Realtime Database\nconst FACES_REF = \"faces\";\nconst DEBUG_REF = \"debug\";\n\n/**\r\n * Save face descriptor to Firebase Realtime Database using username as key\r\n * Enhanced to store more comprehensive face data\r\n * @param {string} userId - User ID (will be stored as additional data)\r\n * @param {string} username - Username to use as primary identifier \r\n * @param {Float32Array} descriptor - Face descriptor data\r\n * @param {Object} metadata - Additional metadata about face detection quality\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const saveFaceToFirebase = async (userId, username, descriptor, metadata = {}) => {\n  console.log(`Starting Firebase save process for user ${username} (ID: ${userId})...`);\n\n  // Validate inputs\n  if (!username || !descriptor) {\n    console.error(\"Missing required parameters for saving face data\");\n    return false;\n  }\n\n  // Sanitize username to create a valid Firebase key\n  const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n\n  // Validate Firebase connection\n  if (!rtdb) {\n    console.error(\"Firebase Realtime Database not initialized\");\n    return false;\n  }\n  try {\n    console.log(`RTDB URL: ${rtdb.app.options.databaseURL}`);\n\n    // First run a basic write test\n    console.log(\"Running connectivity test...\");\n    const testRef = ref(rtdb, `${DEBUG_REF}/connectivity_test`);\n    await set(testRef, {\n      timestamp: new Date().toISOString(),\n      client: navigator.userAgent,\n      success: true\n    });\n    console.log(\"✅ Test write successful\");\n\n    // Convert descriptor to array\n    console.log(\"Preparing descriptor data...\");\n    const descriptorArray = Array.from(descriptor);\n\n    // Define path and create ref - using username as the key\n    const path = `${FACES_REF}/${safeUsername}`;\n    console.log(`Writing to path: ${path}`);\n\n    // Write enhanced metadata\n    const enhancedMetadata = {\n      userId: userId,\n      // Store userId as a reference\n      username: username,\n      descriptorLength: descriptorArray.length,\n      browser: navigator.userAgent.split(' ')[0],\n      userAgent: navigator.userAgent,\n      descriptorSample: descriptorArray.slice(0, 3),\n      // Store sample of first 3 values\n      captureQuality: metadata.quality || 0,\n      detectionCount: metadata.detectionCount || 1,\n      scanDuration: metadata.scanDuration || 0,\n      captureDate: new Date().toISOString(),\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\n      devicePixelRatio: window.devicePixelRatio || 1,\n      platform: navigator.platform\n    };\n    await set(ref(rtdb, `${path}/metadata`), enhancedMetadata);\n    console.log(\"✅ Enhanced metadata written\");\n\n    // Write face quality scores if available\n    if (metadata.scores && metadata.scores.length > 0) {\n      await set(ref(rtdb, `${path}/quality_scores`), metadata.scores);\n      console.log(\"✅ Quality scores written\");\n    }\n\n    // Then write descriptor in smaller batches for better reliability\n    const BATCH_SIZE = 16; // Smaller batches\n    for (let i = 0; i < descriptorArray.length; i += BATCH_SIZE) {\n      const batch = descriptorArray.slice(i, i + BATCH_SIZE);\n      await set(ref(rtdb, `${path}/descriptor_part_${Math.floor(i / BATCH_SIZE)}`), batch);\n      console.log(`✅ Written descriptor batch ${Math.floor(i / BATCH_SIZE) + 1}`);\n    }\n\n    // Finally write the basic info\n    await set(ref(rtdb, `${path}/info`), {\n      userId,\n      username,\n      timestamp: new Date().toISOString(),\n      parts: Math.ceil(descriptorArray.length / BATCH_SIZE)\n    });\n    console.log(\"✅ All data written successfully\");\n\n    // Verify data was written\n    const snapshot = await get(ref(rtdb, `${path}/info`));\n    if (snapshot.exists()) {\n      console.log(\"✅ Verification successful\");\n      return true;\n    } else {\n      console.error(\"❌ Verification failed - data not found after write\");\n      return false;\n    }\n  } catch (error) {\n    console.error(\"❌ Error saving face data to Firebase:\", error);\n    // Provide detailed error information for debugging\n    console.error({\n      errorName: error.name,\n      errorCode: error.code,\n      errorMessage: error.message,\n      errorStack: error.stack\n    });\n    return false;\n  }\n};\n\n/**\r\n * Get face descriptor from Firebase by username with improved error handling\r\n * @param {string} username - Username\r\n * @returns {Promise<{descriptor: Float32Array, metadata: Object}|null>} Face data or null if not found\r\n */\nexport const getFaceFromFirebase = async username => {\n  try {\n    if (!username) {\n      console.error(\"Username is required to get face data\");\n      return null;\n    }\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n\n    // Check if we have the full descriptor in one piece\n    const fullPath = `${FACES_REF}/${safeUsername}`;\n    const fullSnapshot = await get(ref(rtdb, fullPath));\n    if (!fullSnapshot.exists()) {\n      console.log(`No data found for username ${username}`);\n      return null;\n    }\n    const data = fullSnapshot.val();\n    let descriptor = null;\n\n    // Check if we have a simple descriptor array\n    if (data && data.descriptor) {\n      console.log(`Single-part descriptor found for ${username}`);\n      descriptor = new Float32Array(data.descriptor);\n    }\n\n    // Check if we have multi-part descriptor\n    else if (data && data.info && data.info.parts) {\n      console.log(`Multi-part descriptor found for ${username} (${data.info.parts} parts)`);\n\n      // Assemble descriptor from parts\n      const descriptorParts = [];\n      for (let i = 0; i < data.info.parts; i++) {\n        const partKey = `descriptor_part_${i}`;\n        if (data[partKey]) {\n          descriptorParts.push(...data[partKey]);\n        }\n      }\n      if (descriptorParts.length > 0) {\n        descriptor = new Float32Array(descriptorParts);\n      }\n    }\n    if (!descriptor) {\n      console.log(`Data found for ${username} but no valid descriptor`);\n      return null;\n    }\n\n    // Return both descriptor and metadata\n    return {\n      descriptor,\n      metadata: data.metadata || {},\n      info: data.info || {}\n    };\n  } catch (error) {\n    console.error(\"Error getting face from Firebase:\", error);\n    return null;\n  }\n};\n\n/**\r\n * Remove face descriptor from Firebase by username\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const removeFaceFromFirebase = async username => {\n  try {\n    if (!username) {\n      console.error(\"Username is required to remove face data\");\n      return false;\n    }\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\n    await remove(faceRef);\n    console.log(`Face descriptor for ${username} removed from Firebase`);\n    return true;\n  } catch (error) {\n    console.error(\"Error removing face from Firebase:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Check if username has face data in Firebase\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Whether face data exists\r\n */\nexport const hasFaceInFirebase = async username => {\n  try {\n    if (!username) return false;\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\n    const snapshot = await get(faceRef);\n    return snapshot.exists();\n  } catch (error) {\n    console.error(\"Error checking face in Firebase:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Update face metadata for existing record\r\n * @param {string} username - Username\r\n * @param {Object} metadataUpdates - Metadata fields to update\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const updateFaceMetadata = async (username, metadataUpdates) => {\n  try {\n    if (!username || !metadataUpdates) {\n      console.error(\"Username and update data are required\");\n      return false;\n    }\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const metadataRef = ref(rtdb, `${FACES_REF}/${safeUsername}/metadata`);\n\n    // Get current metadata\n    const snapshot = await get(metadataRef);\n    if (!snapshot.exists()) {\n      console.error(`No metadata found for username ${username}`);\n      return false;\n    }\n\n    // Update with new values\n    const currentData = snapshot.val();\n    const updatedData = {\n      ...currentData,\n      ...metadataUpdates,\n      lastUpdated: new Date().toISOString()\n    };\n    await set(metadataRef, updatedData);\n    console.log(`Metadata updated for ${username}`);\n    return true;\n  } catch (error) {\n    console.error(\"Error updating face metadata:\", error);\n    return false;\n  }\n};\n\n/**\r\n * List all faces stored in Firebase\r\n * @param {number} limit - Optional limit of results to return\r\n * @returns {Promise<Array>} Array of face data summaries\r\n */\nexport const listAllFaces = async (limit = 100) => {\n  try {\n    const facesRef = ref(rtdb, FACES_REF);\n    const snapshot = await get(facesRef);\n    if (!snapshot.exists()) {\n      return [];\n    }\n    const allFaces = snapshot.val();\n    const faceList = Object.keys(allFaces).slice(0, limit).map(username => {\n      var _faceData$info, _faceData$metadata, _faceData$info2, _faceData$metadata2;\n      const faceData = allFaces[username];\n      return {\n        username,\n        userId: ((_faceData$info = faceData.info) === null || _faceData$info === void 0 ? void 0 : _faceData$info.userId) || ((_faceData$metadata = faceData.metadata) === null || _faceData$metadata === void 0 ? void 0 : _faceData$metadata.userId),\n        timestamp: ((_faceData$info2 = faceData.info) === null || _faceData$info2 === void 0 ? void 0 : _faceData$info2.timestamp) || ((_faceData$metadata2 = faceData.metadata) === null || _faceData$metadata2 === void 0 ? void 0 : _faceData$metadata2.captureDate),\n        hasDescriptor: !!(faceData.descriptor || faceData.descriptor_part_0)\n      };\n    });\n    return faceList;\n  } catch (error) {\n    console.error(\"Error listing faces:\", error);\n    return [];\n  }\n};\n\n// Keep the old user ID based methods for backward compatibility\n// But mark them as deprecated\n\n/**\r\n * @deprecated Use username-based methods instead\r\n */\nexport const saveFaceToFirebaseById = async (userId, descriptor) => {\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\n  // ...existing code...\n};\n\n/**\r\n * @deprecated Use username-based methods instead\r\n */\nexport const getFaceFromFirebaseById = async userId => {\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\n  // ...existing code...\n};","map":{"version":3,"names":["ref","set","get","remove","serverTimestamp","rtdb","FACES_REF","DEBUG_REF","saveFaceToFirebase","userId","username","descriptor","metadata","console","log","error","safeUsername","replace","app","options","databaseURL","testRef","timestamp","Date","toISOString","client","navigator","userAgent","success","descriptorArray","Array","from","path","enhancedMetadata","descriptorLength","length","browser","split","descriptorSample","slice","captureQuality","quality","detectionCount","scanDuration","captureDate","screenResolution","window","screen","width","height","devicePixelRatio","platform","scores","BATCH_SIZE","i","batch","Math","floor","parts","ceil","snapshot","exists","errorName","name","errorCode","code","errorMessage","message","errorStack","stack","getFaceFromFirebase","fullPath","fullSnapshot","data","val","Float32Array","info","descriptorParts","partKey","push","removeFaceFromFirebase","faceRef","hasFaceInFirebase","updateFaceMetadata","metadataUpdates","metadataRef","currentData","updatedData","lastUpdated","listAllFaces","limit","facesRef","allFaces","faceList","Object","keys","map","_faceData$info","_faceData$metadata","_faceData$info2","_faceData$metadata2","faceData","hasDescriptor","descriptor_part_0","saveFaceToFirebaseById","warn","getFaceFromFirebaseById"],"sources":["D:/Movies/Aniket/test2/test/src/services/firebaseFaceService.js"],"sourcesContent":["import { ref, set, get, remove, serverTimestamp } from \"firebase/database\";\r\nimport { rtdb } from \"../firebase/config\";\r\n\r\n// Reference to faces in Firebase Realtime Database\r\nconst FACES_REF = \"faces\";\r\nconst DEBUG_REF = \"debug\";\r\n\r\n/**\r\n * Save face descriptor to Firebase Realtime Database using username as key\r\n * Enhanced to store more comprehensive face data\r\n * @param {string} userId - User ID (will be stored as additional data)\r\n * @param {string} username - Username to use as primary identifier \r\n * @param {Float32Array} descriptor - Face descriptor data\r\n * @param {Object} metadata - Additional metadata about face detection quality\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const saveFaceToFirebase = async (userId, username, descriptor, metadata = {}) => {\r\n  console.log(`Starting Firebase save process for user ${username} (ID: ${userId})...`);\r\n  \r\n  // Validate inputs\r\n  if (!username || !descriptor) {\r\n    console.error(\"Missing required parameters for saving face data\");\r\n    return false;\r\n  }\r\n  \r\n  // Sanitize username to create a valid Firebase key\r\n  const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n  \r\n  // Validate Firebase connection\r\n  if (!rtdb) {\r\n    console.error(\"Firebase Realtime Database not initialized\");\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    console.log(`RTDB URL: ${rtdb.app.options.databaseURL}`);\r\n    \r\n    // First run a basic write test\r\n    console.log(\"Running connectivity test...\");\r\n    const testRef = ref(rtdb, `${DEBUG_REF}/connectivity_test`);\r\n    await set(testRef, {\r\n      timestamp: new Date().toISOString(),\r\n      client: navigator.userAgent,\r\n      success: true\r\n    });\r\n    console.log(\"✅ Test write successful\");\r\n    \r\n    // Convert descriptor to array\r\n    console.log(\"Preparing descriptor data...\");\r\n    const descriptorArray = Array.from(descriptor);\r\n    \r\n    // Define path and create ref - using username as the key\r\n    const path = `${FACES_REF}/${safeUsername}`;\r\n    console.log(`Writing to path: ${path}`);\r\n    \r\n    // Write enhanced metadata\r\n    const enhancedMetadata = {\r\n      userId: userId, // Store userId as a reference\r\n      username: username,\r\n      descriptorLength: descriptorArray.length,\r\n      browser: navigator.userAgent.split(' ')[0],\r\n      userAgent: navigator.userAgent,\r\n      descriptorSample: descriptorArray.slice(0, 3), // Store sample of first 3 values\r\n      captureQuality: metadata.quality || 0,\r\n      detectionCount: metadata.detectionCount || 1,\r\n      scanDuration: metadata.scanDuration || 0,\r\n      captureDate: new Date().toISOString(),\r\n      screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n      devicePixelRatio: window.devicePixelRatio || 1,\r\n      platform: navigator.platform\r\n    };\r\n    \r\n    await set(ref(rtdb, `${path}/metadata`), enhancedMetadata);\r\n    console.log(\"✅ Enhanced metadata written\");\r\n    \r\n    // Write face quality scores if available\r\n    if (metadata.scores && metadata.scores.length > 0) {\r\n      await set(ref(rtdb, `${path}/quality_scores`), metadata.scores);\r\n      console.log(\"✅ Quality scores written\");\r\n    }\r\n    \r\n    // Then write descriptor in smaller batches for better reliability\r\n    const BATCH_SIZE = 16; // Smaller batches\r\n    for (let i = 0; i < descriptorArray.length; i += BATCH_SIZE) {\r\n      const batch = descriptorArray.slice(i, i + BATCH_SIZE);\r\n      await set(ref(rtdb, `${path}/descriptor_part_${Math.floor(i/BATCH_SIZE)}`), batch);\r\n      console.log(`✅ Written descriptor batch ${Math.floor(i/BATCH_SIZE) + 1}`);\r\n    }\r\n    \r\n    // Finally write the basic info\r\n    await set(ref(rtdb, `${path}/info`), {\r\n      userId,\r\n      username,\r\n      timestamp: new Date().toISOString(),\r\n      parts: Math.ceil(descriptorArray.length / BATCH_SIZE)\r\n    });\r\n    \r\n    console.log(\"✅ All data written successfully\");\r\n    \r\n    // Verify data was written\r\n    const snapshot = await get(ref(rtdb, `${path}/info`));\r\n    if (snapshot.exists()) {\r\n      console.log(\"✅ Verification successful\");\r\n      return true;\r\n    } else {\r\n      console.error(\"❌ Verification failed - data not found after write\");\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"❌ Error saving face data to Firebase:\", error);\r\n    // Provide detailed error information for debugging\r\n    console.error({\r\n      errorName: error.name,\r\n      errorCode: error.code,\r\n      errorMessage: error.message,\r\n      errorStack: error.stack\r\n    });\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get face descriptor from Firebase by username with improved error handling\r\n * @param {string} username - Username\r\n * @returns {Promise<{descriptor: Float32Array, metadata: Object}|null>} Face data or null if not found\r\n */\r\nexport const getFaceFromFirebase = async (username) => {\r\n  try {\r\n    if (!username) {\r\n      console.error(\"Username is required to get face data\");\r\n      return null;\r\n    }\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    \r\n    // Check if we have the full descriptor in one piece\r\n    const fullPath = `${FACES_REF}/${safeUsername}`;\r\n    const fullSnapshot = await get(ref(rtdb, fullPath));\r\n    \r\n    if (!fullSnapshot.exists()) {\r\n      console.log(`No data found for username ${username}`);\r\n      return null;\r\n    }\r\n    \r\n    const data = fullSnapshot.val();\r\n    let descriptor = null;\r\n    \r\n    // Check if we have a simple descriptor array\r\n    if (data && data.descriptor) {\r\n      console.log(`Single-part descriptor found for ${username}`);\r\n      descriptor = new Float32Array(data.descriptor);\r\n    }\r\n    \r\n    // Check if we have multi-part descriptor\r\n    else if (data && data.info && data.info.parts) {\r\n      console.log(`Multi-part descriptor found for ${username} (${data.info.parts} parts)`);\r\n      \r\n      // Assemble descriptor from parts\r\n      const descriptorParts = [];\r\n      for (let i = 0; i < data.info.parts; i++) {\r\n        const partKey = `descriptor_part_${i}`;\r\n        if (data[partKey]) {\r\n          descriptorParts.push(...data[partKey]);\r\n        }\r\n      }\r\n      \r\n      if (descriptorParts.length > 0) {\r\n        descriptor = new Float32Array(descriptorParts);\r\n      }\r\n    }\r\n    \r\n    if (!descriptor) {\r\n      console.log(`Data found for ${username} but no valid descriptor`);\r\n      return null;\r\n    }\r\n    \r\n    // Return both descriptor and metadata\r\n    return {\r\n      descriptor,\r\n      metadata: data.metadata || {},\r\n      info: data.info || {}\r\n    };\r\n  } catch (error) {\r\n    console.error(\"Error getting face from Firebase:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Remove face descriptor from Firebase by username\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const removeFaceFromFirebase = async (username) => {\r\n  try {\r\n    if (!username) {\r\n      console.error(\"Username is required to remove face data\");\r\n      return false;\r\n    }\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\r\n    await remove(faceRef);\r\n    \r\n    console.log(`Face descriptor for ${username} removed from Firebase`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error removing face from Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if username has face data in Firebase\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Whether face data exists\r\n */\r\nexport const hasFaceInFirebase = async (username) => {\r\n  try {\r\n    if (!username) return false;\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\r\n    const snapshot = await get(faceRef);\r\n    \r\n    return snapshot.exists();\r\n  } catch (error) {\r\n    console.error(\"Error checking face in Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Update face metadata for existing record\r\n * @param {string} username - Username\r\n * @param {Object} metadataUpdates - Metadata fields to update\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const updateFaceMetadata = async (username, metadataUpdates) => {\r\n  try {\r\n    if (!username || !metadataUpdates) {\r\n      console.error(\"Username and update data are required\");\r\n      return false;\r\n    }\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const metadataRef = ref(rtdb, `${FACES_REF}/${safeUsername}/metadata`);\r\n    \r\n    // Get current metadata\r\n    const snapshot = await get(metadataRef);\r\n    if (!snapshot.exists()) {\r\n      console.error(`No metadata found for username ${username}`);\r\n      return false;\r\n    }\r\n    \r\n    // Update with new values\r\n    const currentData = snapshot.val();\r\n    const updatedData = { \r\n      ...currentData, \r\n      ...metadataUpdates,\r\n      lastUpdated: new Date().toISOString() \r\n    };\r\n    \r\n    await set(metadataRef, updatedData);\r\n    console.log(`Metadata updated for ${username}`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error updating face metadata:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * List all faces stored in Firebase\r\n * @param {number} limit - Optional limit of results to return\r\n * @returns {Promise<Array>} Array of face data summaries\r\n */\r\nexport const listAllFaces = async (limit = 100) => {\r\n  try {\r\n    const facesRef = ref(rtdb, FACES_REF);\r\n    const snapshot = await get(facesRef);\r\n    \r\n    if (!snapshot.exists()) {\r\n      return [];\r\n    }\r\n    \r\n    const allFaces = snapshot.val();\r\n    const faceList = Object.keys(allFaces)\r\n      .slice(0, limit)\r\n      .map(username => {\r\n        const faceData = allFaces[username];\r\n        return {\r\n          username,\r\n          userId: faceData.info?.userId || faceData.metadata?.userId,\r\n          timestamp: faceData.info?.timestamp || faceData.metadata?.captureDate,\r\n          hasDescriptor: !!(faceData.descriptor || faceData.descriptor_part_0)\r\n        };\r\n      });\r\n    \r\n    return faceList;\r\n  } catch (error) {\r\n    console.error(\"Error listing faces:\", error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Keep the old user ID based methods for backward compatibility\r\n// But mark them as deprecated\r\n\r\n/**\r\n * @deprecated Use username-based methods instead\r\n */\r\nexport const saveFaceToFirebaseById = async (userId, descriptor) => {\r\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\r\n  // ...existing code...\r\n};\r\n\r\n/**\r\n * @deprecated Use username-based methods instead\r\n */\r\nexport const getFaceFromFirebaseById = async (userId) => {\r\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\r\n  // ...existing code...\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}