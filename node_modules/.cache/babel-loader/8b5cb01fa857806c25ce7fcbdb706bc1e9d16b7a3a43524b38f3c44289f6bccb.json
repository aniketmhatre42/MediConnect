{"ast":null,"code":"import { ref, set, get, remove, serverTimestamp } from \"firebase/database\";\nimport { rtdb } from \"../firebase/config\";\n\n// Reference to faces in Firebase Realtime Database\nconst FACES_REF = \"faces\";\nconst DEBUG_REF = \"debug\";\n\n/**\r\n * Save face descriptor to Firebase Realtime Database\r\n * @param {string} userId - User ID\r\n * @param {Float32Array} descriptor - Face descriptor data\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const saveFaceToFirebase = async (userId, descriptor) => {\n  console.log(`Starting Firebase save process for user ${userId}...`);\n\n  // Validate inputs\n  if (!userId || !descriptor) {\n    console.error(\"Missing required parameters for saving face data\");\n    return false;\n  }\n\n  // Validate Firebase connection\n  if (!rtdb) {\n    console.error(\"Firebase Realtime Database not initialized\", {\n      rtdbExists: !!rtdb,\n      rtdbType: typeof rtdb\n    });\n    return false;\n  }\n  try {\n    console.log(`RTDB URL: ${rtdb.app.options.databaseURL}`);\n\n    // First run a basic write test\n    console.log(\"Running connectivity test...\");\n    const testRef = ref(rtdb, `${DEBUG_REF}/connectivity_test`);\n    await set(testRef, {\n      timestamp: new Date().toISOString(),\n      client: navigator.userAgent,\n      success: true\n    });\n    console.log(\"✅ Test write successful\");\n\n    // Convert descriptor to array\n    console.log(\"Preparing descriptor data...\");\n    const descriptorArray = Array.from(descriptor);\n\n    // Prepare data to save\n    const faceData = {\n      userId,\n      descriptor: descriptorArray,\n      timestamp: new Date().toISOString(),\n      // Use direct timestamp instead of serverTimestamp\n      metadata: {\n        userAgent: navigator.userAgent,\n        descriptorLength: descriptorArray.length,\n        browser: navigator.userAgent.split(' ')[0],\n        descriptorSample: descriptorArray.slice(0, 3) // Store sample of first 3 values\n      }\n    };\n\n    // Define path and create ref\n    const path = `${FACES_REF}/${userId}`;\n    console.log(`Writing to path: ${path}`);\n    const faceRef = ref(rtdb, path);\n\n    // Write data in chunks if needed (to avoid potential size limits)\n    // First write metadata\n    await set(ref(rtdb, `${path}/metadata`), faceData.metadata);\n    console.log(\"✅ Metadata written\");\n\n    // Then write descriptor in batches of 20\n    const BATCH_SIZE = 20;\n    for (let i = 0; i < descriptorArray.length; i += BATCH_SIZE) {\n      const batch = descriptorArray.slice(i, i + BATCH_SIZE);\n      await set(ref(rtdb, `${path}/descriptor_part_${i / BATCH_SIZE}`), batch);\n    }\n\n    // Finally write the basic info\n    await set(ref(rtdb, `${path}/info`), {\n      userId,\n      timestamp: faceData.timestamp,\n      parts: Math.ceil(descriptorArray.length / BATCH_SIZE)\n    });\n    console.log(\"✅ All data written successfully\");\n\n    // Verify data was written\n    const snapshot = await get(ref(rtdb, `${path}/info`));\n    if (snapshot.exists()) {\n      console.log(\"✅ Verification successful\");\n      return true;\n    } else {\n      console.error(\"❌ Verification failed - data not found after write\");\n      return false;\n    }\n  } catch (error) {\n    console.error(\"❌ Error saving face data to Firebase:\", error);\n    // Print detailed error info\n    console.error(\"Error details:\", {\n      name: error.name,\n      code: error.code,\n      message: error.message,\n      stack: error.stack\n    });\n    return false;\n  }\n};\n\n/**\r\n * Get face descriptor from Firebase Realtime Database\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Float32Array|null>} Face descriptor or null if not found\r\n */\nexport const getFaceFromFirebase = async userId => {\n  try {\n    if (!userId) {\n      console.error(\"User ID is required to get face data\");\n      return null;\n    }\n    const faceRef = ref(rtdb, `${FACES_REF}/${userId}`);\n    const snapshot = await get(faceRef);\n    if (snapshot.exists()) {\n      const data = snapshot.val();\n      if (data && data.descriptor) {\n        console.log(`Face descriptor for ${userId} retrieved from Firebase`);\n        return new Float32Array(data.descriptor);\n      }\n    }\n    console.log(`No face descriptor found for ${userId} in Firebase`);\n    return null;\n  } catch (error) {\n    console.error(\"Error getting face from Firebase:\", error);\n    return null;\n  }\n};\n\n/**\r\n * Remove face descriptor from Firebase Realtime Database\r\n * @param {string} userId - User ID\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const removeFaceFromFirebase = async userId => {\n  try {\n    if (!userId) {\n      console.error(\"User ID is required to remove face data\");\n      return false;\n    }\n    const faceRef = ref(rtdb, `${FACES_REF}/${userId}`);\n    await remove(faceRef);\n    console.log(`Face descriptor for ${userId} removed from Firebase`);\n    return true;\n  } catch (error) {\n    console.error(\"Error removing face from Firebase:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Check if user has face data in Firebase\r\n * @param {string} userId - User ID\r\n * @returns {Promise<boolean>} Whether face data exists\r\n */\nexport const hasFaceInFirebase = async userId => {\n  try {\n    if (!userId) return false;\n    const faceRef = ref(rtdb, `${FACES_REF}/${userId}`);\n    const snapshot = await get(faceRef);\n    return snapshot.exists();\n  } catch (error) {\n    console.error(\"Error checking face in Firebase:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["ref","set","get","remove","serverTimestamp","rtdb","FACES_REF","DEBUG_REF","saveFaceToFirebase","userId","descriptor","console","log","error","rtdbExists","rtdbType","app","options","databaseURL","testRef","timestamp","Date","toISOString","client","navigator","userAgent","success","descriptorArray","Array","from","faceData","metadata","descriptorLength","length","browser","split","descriptorSample","slice","path","faceRef","BATCH_SIZE","i","batch","parts","Math","ceil","snapshot","exists","name","code","message","stack","getFaceFromFirebase","data","val","Float32Array","removeFaceFromFirebase","hasFaceInFirebase"],"sources":["D:/Movies/Aniket/test2/test/src/services/firebaseFaceService.js"],"sourcesContent":["import { ref, set, get, remove, serverTimestamp } from \"firebase/database\";\r\nimport { rtdb } from \"../firebase/config\";\r\n\r\n// Reference to faces in Firebase Realtime Database\r\nconst FACES_REF = \"faces\";\r\nconst DEBUG_REF = \"debug\";\r\n\r\n/**\r\n * Save face descriptor to Firebase Realtime Database\r\n * @param {string} userId - User ID\r\n * @param {Float32Array} descriptor - Face descriptor data\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const saveFaceToFirebase = async (userId, descriptor) => {\r\n  console.log(`Starting Firebase save process for user ${userId}...`);\r\n  \r\n  // Validate inputs\r\n  if (!userId || !descriptor) {\r\n    console.error(\"Missing required parameters for saving face data\");\r\n    return false;\r\n  }\r\n  \r\n  // Validate Firebase connection\r\n  if (!rtdb) {\r\n    console.error(\"Firebase Realtime Database not initialized\", {\r\n      rtdbExists: !!rtdb,\r\n      rtdbType: typeof rtdb\r\n    });\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    console.log(`RTDB URL: ${rtdb.app.options.databaseURL}`);\r\n    \r\n    // First run a basic write test\r\n    console.log(\"Running connectivity test...\");\r\n    const testRef = ref(rtdb, `${DEBUG_REF}/connectivity_test`);\r\n    await set(testRef, {\r\n      timestamp: new Date().toISOString(),\r\n      client: navigator.userAgent,\r\n      success: true\r\n    });\r\n    console.log(\"✅ Test write successful\");\r\n    \r\n    // Convert descriptor to array\r\n    console.log(\"Preparing descriptor data...\");\r\n    const descriptorArray = Array.from(descriptor);\r\n    \r\n    // Prepare data to save\r\n    const faceData = {\r\n      userId,\r\n      descriptor: descriptorArray,\r\n      timestamp: new Date().toISOString(), // Use direct timestamp instead of serverTimestamp\r\n      metadata: {\r\n        userAgent: navigator.userAgent,\r\n        descriptorLength: descriptorArray.length,\r\n        browser: navigator.userAgent.split(' ')[0],\r\n        descriptorSample: descriptorArray.slice(0, 3) // Store sample of first 3 values\r\n      }\r\n    };\r\n    \r\n    // Define path and create ref\r\n    const path = `${FACES_REF}/${userId}`;\r\n    console.log(`Writing to path: ${path}`);\r\n    const faceRef = ref(rtdb, path);\r\n    \r\n    // Write data in chunks if needed (to avoid potential size limits)\r\n    // First write metadata\r\n    await set(ref(rtdb, `${path}/metadata`), faceData.metadata);\r\n    console.log(\"✅ Metadata written\");\r\n    \r\n    // Then write descriptor in batches of 20\r\n    const BATCH_SIZE = 20;\r\n    for (let i = 0; i < descriptorArray.length; i += BATCH_SIZE) {\r\n      const batch = descriptorArray.slice(i, i + BATCH_SIZE);\r\n      await set(ref(rtdb, `${path}/descriptor_part_${i/BATCH_SIZE}`), batch);\r\n    }\r\n    \r\n    // Finally write the basic info\r\n    await set(ref(rtdb, `${path}/info`), {\r\n      userId,\r\n      timestamp: faceData.timestamp,\r\n      parts: Math.ceil(descriptorArray.length / BATCH_SIZE)\r\n    });\r\n    \r\n    console.log(\"✅ All data written successfully\");\r\n    \r\n    // Verify data was written\r\n    const snapshot = await get(ref(rtdb, `${path}/info`));\r\n    if (snapshot.exists()) {\r\n      console.log(\"✅ Verification successful\");\r\n      return true;\r\n    } else {\r\n      console.error(\"❌ Verification failed - data not found after write\");\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"❌ Error saving face data to Firebase:\", error);\r\n    // Print detailed error info\r\n    console.error(\"Error details:\", {\r\n      name: error.name,\r\n      code: error.code,\r\n      message: error.message,\r\n      stack: error.stack\r\n    });\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get face descriptor from Firebase Realtime Database\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Float32Array|null>} Face descriptor or null if not found\r\n */\r\nexport const getFaceFromFirebase = async (userId) => {\r\n  try {\r\n    if (!userId) {\r\n      console.error(\"User ID is required to get face data\");\r\n      return null;\r\n    }\r\n    \r\n    const faceRef = ref(rtdb, `${FACES_REF}/${userId}`);\r\n    const snapshot = await get(faceRef);\r\n    \r\n    if (snapshot.exists()) {\r\n      const data = snapshot.val();\r\n      if (data && data.descriptor) {\r\n        console.log(`Face descriptor for ${userId} retrieved from Firebase`);\r\n        return new Float32Array(data.descriptor);\r\n      }\r\n    }\r\n    \r\n    console.log(`No face descriptor found for ${userId} in Firebase`);\r\n    return null;\r\n  } catch (error) {\r\n    console.error(\"Error getting face from Firebase:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Remove face descriptor from Firebase Realtime Database\r\n * @param {string} userId - User ID\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const removeFaceFromFirebase = async (userId) => {\r\n  try {\r\n    if (!userId) {\r\n      console.error(\"User ID is required to remove face data\");\r\n      return false;\r\n    }\r\n    \r\n    const faceRef = ref(rtdb, `${FACES_REF}/${userId}`);\r\n    await remove(faceRef);\r\n    \r\n    console.log(`Face descriptor for ${userId} removed from Firebase`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error removing face from Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if user has face data in Firebase\r\n * @param {string} userId - User ID\r\n * @returns {Promise<boolean>} Whether face data exists\r\n */\r\nexport const hasFaceInFirebase = async (userId) => {\r\n  try {\r\n    if (!userId) return false;\r\n    \r\n    const faceRef = ref(rtdb, `${FACES_REF}/${userId}`);\r\n    const snapshot = await get(faceRef);\r\n    \r\n    return snapshot.exists();\r\n  } catch (error) {\r\n    console.error(\"Error checking face in Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}