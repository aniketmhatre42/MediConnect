{"ast":null,"code":"import { ref, set, get, remove, serverTimestamp } from \"firebase/database\";\nimport { rtdb } from \"../firebase/config\";\nimport * as faceapi from 'face-api.js';\n\n// Reference to faces in Firebase Realtime Database\nconst FACES_REF = \"faces\";\nconst DEBUG_REF = \"debug\";\n\n/**\r\n * Save face descriptor to Firebase Realtime Database using username as key\r\n * @param {string} userId - User ID (will be stored as additional data)\r\n * @param {string} username - Username to use as primary identifier \r\n * @param {Float32Array} descriptor - Face descriptor data\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const saveFaceToFirebase = async (userId, username, descriptor) => {\n  console.log(`Starting Firebase save process for user ${username} (ID: ${userId})...`);\n\n  // Validate inputs\n  if (!username || !descriptor) {\n    console.error(\"Missing required parameters for saving face data\");\n    return false;\n  }\n\n  // Sanitize username to create a valid Firebase key\n  const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n\n  // Validate Firebase connection\n  if (!rtdb) {\n    console.error(\"Firebase Realtime Database not initialized\");\n    return false;\n  }\n  try {\n    console.log(`RTDB URL: ${rtdb.app.options.databaseURL}`);\n\n    // First run a basic write test\n    console.log(\"Running connectivity test...\");\n    const testRef = ref(rtdb, `${DEBUG_REF}/connectivity_test`);\n    await set(testRef, {\n      timestamp: new Date().toISOString(),\n      client: navigator.userAgent,\n      success: true\n    });\n    console.log(\"✅ Test write successful\");\n\n    // Convert descriptor to array\n    console.log(\"Preparing descriptor data...\");\n    const descriptorArray = Array.from(descriptor);\n\n    // Define path and create ref - using username as the key\n    const path = `${FACES_REF}/${safeUsername}`;\n    console.log(`Writing to path: ${path}`);\n\n    // Write metadata first\n    await set(ref(rtdb, `${path}/metadata`), {\n      userId: userId,\n      // Store userId as a reference\n      username: username,\n      descriptorLength: descriptorArray.length,\n      browser: navigator.userAgent.split(' ')[0],\n      userAgent: navigator.userAgent,\n      descriptorSample: descriptorArray.slice(0, 3) // Store sample of first 3 values\n    });\n    console.log(\"✅ Metadata written\");\n\n    // Then write descriptor in batches of 20\n    const BATCH_SIZE = 20;\n    for (let i = 0; i < descriptorArray.length; i += BATCH_SIZE) {\n      const batch = descriptorArray.slice(i, i + BATCH_SIZE);\n      await set(ref(rtdb, `${path}/descriptor_part_${i / BATCH_SIZE}`), batch);\n    }\n\n    // Finally write the basic info\n    await set(ref(rtdb, `${path}/info`), {\n      userId,\n      username,\n      timestamp: new Date().toISOString(),\n      parts: Math.ceil(descriptorArray.length / BATCH_SIZE)\n    });\n    console.log(\"✅ All data written successfully\");\n\n    // Verify data was written\n    const snapshot = await get(ref(rtdb, `${path}/info`));\n    if (snapshot.exists()) {\n      console.log(\"✅ Verification successful\");\n      return true;\n    } else {\n      console.error(\"❌ Verification failed - data not found after write\");\n      return false;\n    }\n  } catch (error) {\n    console.error(\"❌ Error saving face data to Firebase:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Get face descriptor from Firebase by username\r\n * @param {string} username - Username\r\n * @returns {Promise<Float32Array|null>} Face descriptor or null if not found\r\n */\nexport const getFaceFromFirebase = async username => {\n  try {\n    if (!username) {\n      console.error(\"Username is required to get face data\");\n      return null;\n    }\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n\n    // Check if we have the full descriptor in one piece\n    const fullPath = `${FACES_REF}/${safeUsername}`;\n    const fullSnapshot = await get(ref(rtdb, fullPath));\n    if (!fullSnapshot.exists()) {\n      console.log(`No data found for username ${username}`);\n      return null;\n    }\n    const data = fullSnapshot.val();\n\n    // Check if we have a simple descriptor array\n    if (data && data.descriptor) {\n      console.log(`Single-part descriptor found for ${username}`);\n      return new Float32Array(data.descriptor);\n    }\n\n    // Check if we have multi-part descriptor\n    if (data && data.info && data.info.parts) {\n      console.log(`Multi-part descriptor found for ${username} (${data.info.parts} parts)`);\n\n      // Assemble descriptor from parts\n      const descriptorParts = [];\n      for (let i = 0; i < data.info.parts; i++) {\n        const partKey = `descriptor_part_${i}`;\n        if (data[partKey]) {\n          descriptorParts.push(...data[partKey]);\n        }\n      }\n      if (descriptorParts.length > 0) {\n        return new Float32Array(descriptorParts);\n      }\n    }\n    console.log(`Data found for ${username} but no valid descriptor`);\n    return null;\n  } catch (error) {\n    console.error(\"Error getting face from Firebase:\", error);\n    return null;\n  }\n};\n\n/**\r\n * Remove face descriptor from Firebase by username\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const removeFaceFromFirebase = async username => {\n  try {\n    if (!username) {\n      console.error(\"Username is required to remove face data\");\n      return false;\n    }\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\n    await remove(faceRef);\n    console.log(`Face descriptor for ${username} removed from Firebase`);\n    return true;\n  } catch (error) {\n    console.error(\"Error removing face from Firebase:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Check if username has face data in Firebase\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Whether face data exists\r\n */\nexport const hasFaceInFirebase = async username => {\n  try {\n    if (!username) return false;\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\n    const snapshot = await get(faceRef);\n    return snapshot.exists();\n  } catch (error) {\n    console.error(\"Error checking face in Firebase:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Check if a face descriptor already exists in the database under a different username\r\n * @param {Float32Array} descriptor - Face descriptor to check\r\n * @param {string} currentUsername - Username to exclude from the check\r\n * @returns {Promise<{exists: boolean, username: string|null}>} Result with exists flag and username if found\r\n */\nexport const checkFaceExists = async (descriptor, currentUsername) => {\n  try {\n    if (!descriptor) {\n      console.warn(\"No descriptor provided to checkFaceExists\");\n      return {\n        exists: false,\n        username: null\n      };\n    }\n    console.log(`Checking if face already exists (exclude username: ${currentUsername})`);\n\n    // Make sure rtdb is initialized\n    if (!rtdb) {\n      console.warn(\"Firebase Realtime Database not initialized, skipping face check\");\n      return {\n        exists: false,\n        username: null,\n        error: \"Database not initialized\"\n      };\n    }\n    try {\n      // Get all usernames from the database\n      const facesRef = ref(rtdb, FACES_REF);\n      const snapshot = await get(facesRef);\n      if (!snapshot.exists()) {\n        console.log(\"No faces found in database, skipping comparison\");\n        return {\n          exists: false,\n          username: null\n        };\n      }\n      const data = snapshot.val();\n      if (!data) {\n        console.log(\"Snapshot exists but data is null\");\n        return {\n          exists: false,\n          username: null\n        };\n      }\n      const allUsernames = Object.keys(data);\n      if (allUsernames.length === 0) {\n        console.log(\"No usernames found in data\");\n        return {\n          exists: false,\n          username: null\n        };\n      }\n      console.log(`Found ${allUsernames.length} faces in database`);\n\n      // Rest of the function remains unchanged\n      // ...existing code...\n\n      // Threshold for face matching (adjust based on your requirements)\n      // Lower value = stricter matching, higher value = more lenient\n      const MATCH_THRESHOLD = 0.4; // Default threshold (stricter)\n      const POSSIBLE_MATCH_THRESHOLD = 0.6; // For possible matches (more lenient)\n\n      const currentUsernameNormalized = currentUsername === null || currentUsername === void 0 ? void 0 : currentUsername.replace(/[.#$/[\\]]/g, '_');\n      let bestMatch = {\n        username: null,\n        distance: 1.0\n      };\n\n      // Track all distances for debugging\n      const allDistances = [];\n\n      // Check against each existing face\n      for (const username of allUsernames) {\n        // Skip the current username we're registering with\n        if (username === currentUsernameNormalized) {\n          continue;\n        }\n\n        // Get the descriptor for this username\n        let existingDescriptor;\n        try {\n          existingDescriptor = await getFaceFromFirebase(username);\n          if (!existingDescriptor) {\n            console.log(`No descriptor found for username: ${username}`);\n            continue;\n          }\n        } catch (err) {\n          console.warn(`Error getting descriptor for ${username}:`, err);\n          continue;\n        }\n        try {\n          // Normalize descriptors to ensure they're Float32Array\n          const descriptorA = descriptor instanceof Float32Array ? descriptor : new Float32Array(descriptor);\n          const descriptorB = existingDescriptor instanceof Float32Array ? existingDescriptor : new Float32Array(existingDescriptor);\n\n          // Calculate the similarity distance between faces\n          const distance = faceapi.euclideanDistance(descriptorA, descriptorB);\n\n          // Track all distances for debugging\n          allDistances.push({\n            username,\n            distance\n          });\n\n          // Keep track of the best match\n          if (distance < bestMatch.distance) {\n            bestMatch = {\n              username,\n              distance\n            };\n          }\n\n          // Log this comparison\n          console.log(`Face comparison with ${username}: Distance=${distance.toFixed(3)}`);\n\n          // If the distance is below the threshold, it's likely the same person\n          if (distance < MATCH_THRESHOLD) {\n            console.log(`MATCH FOUND! Username: ${username}, Distance: ${distance}`);\n            return {\n              exists: true,\n              username: username,\n              distance: distance,\n              confidence: 'high'\n            };\n          }\n        } catch (compErr) {\n          console.warn(`Error comparing with ${username}:`, compErr);\n          continue;\n        }\n      }\n\n      // Sort all distances for clearer debugging\n      allDistances.sort((a, b) => a.distance - b.distance);\n      console.log(\"All face distances:\", allDistances);\n\n      // If we didn't find a definite match but have a possible match\n      if (bestMatch.username && bestMatch.distance < POSSIBLE_MATCH_THRESHOLD) {\n        console.log(`Possible match found: ${bestMatch.username} with distance ${bestMatch.distance}`);\n        return {\n          exists: true,\n          username: bestMatch.username,\n          distance: bestMatch.distance,\n          confidence: 'medium'\n        };\n      }\n      console.log(\"No matching face found\");\n      return {\n        exists: false,\n        username: null\n      };\n    } catch (err) {\n      console.warn(\"Error during face checking:\", err);\n      // Return no match if there's an error, don't block the registration\n      return {\n        exists: false,\n        username: null,\n        error: err.message\n      };\n    }\n  } catch (error) {\n    console.error(\"Error checking if face exists:\", error);\n    return {\n      exists: false,\n      username: null,\n      error: error.message\n    };\n  }\n};\n\n/**\r\n * Get all faces from Firebase for comparison\r\n * @returns {Promise<Array>} Array of face data objects\r\n */\nexport const getAllFaces = async () => {\n  try {\n    const facesRef = ref(rtdb, FACES_REF);\n    const snapshot = await get(facesRef);\n    if (!snapshot.exists()) return [];\n    const data = snapshot.val();\n    return Object.entries(data).map(([username, userData]) => {\n      return {\n        username,\n        ...userData\n      };\n    });\n  } catch (error) {\n    console.error(\"Error getting all faces:\", error);\n    return [];\n  }\n};\n\n/**\r\n * Update face descriptor for an existing username\r\n * @param {string} username - Username to update\r\n * @param {Float32Array} descriptor - New face descriptor\r\n * @returns {Promise<boolean>} Success status\r\n */\nexport const updateFaceDescriptor = async (username, descriptor) => {\n  // Simply use the same function to save - it will overwrite existing data\n  try {\n    var _existingData$info;\n    if (!username || !descriptor) {\n      console.error(\"Missing required parameters for updating face data\");\n      return false;\n    }\n\n    // Get the existing data first to preserve any other fields\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const existingData = await getFaceDetailsFromFirebase(safeUsername);\n    const userId = (existingData === null || existingData === void 0 ? void 0 : (_existingData$info = existingData.info) === null || _existingData$info === void 0 ? void 0 : _existingData$info.userId) || `user_${Date.now()}`;\n    console.log(`Updating face descriptor for username: ${username} with userId: ${userId}`);\n\n    // Use the main save function which will overwrite existing data\n    return await saveFaceToFirebase(userId, username, descriptor);\n  } catch (error) {\n    console.error(\"Error updating face descriptor:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Get face details from Firebase (not just descriptor)\r\n * @param {string} username - Username\r\n * @returns {Promise<Object|null>} Full face data or null if not found\r\n */\nexport const getFaceDetailsFromFirebase = async username => {\n  try {\n    if (!username) return null;\n\n    // Sanitize username for Firebase\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\n    const snapshot = await get(faceRef);\n    return snapshot.exists() ? snapshot.val() : null;\n  } catch (error) {\n    console.error(\"Error getting face details:\", error);\n    return null;\n  }\n};\n\n// Keep the old user ID based methods for backward compatibility\n// But mark them as deprecated\n\n/**\r\n * @deprecated Use username-based methods instead\r\n */\nexport const saveFaceToFirebaseById = async (userId, descriptor) => {\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\n  // ...existing code...\n};\n\n/**\r\n * @deprecated Use username-based methods instead\r\n */\nexport const getFaceFromFirebaseById = async userId => {\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\n  // ...existing code...\n};","map":{"version":3,"names":["ref","set","get","remove","serverTimestamp","rtdb","faceapi","FACES_REF","DEBUG_REF","saveFaceToFirebase","userId","username","descriptor","console","log","error","safeUsername","replace","app","options","databaseURL","testRef","timestamp","Date","toISOString","client","navigator","userAgent","success","descriptorArray","Array","from","path","descriptorLength","length","browser","split","descriptorSample","slice","BATCH_SIZE","i","batch","parts","Math","ceil","snapshot","exists","getFaceFromFirebase","fullPath","fullSnapshot","data","val","Float32Array","info","descriptorParts","partKey","push","removeFaceFromFirebase","faceRef","hasFaceInFirebase","checkFaceExists","currentUsername","warn","facesRef","allUsernames","Object","keys","MATCH_THRESHOLD","POSSIBLE_MATCH_THRESHOLD","currentUsernameNormalized","bestMatch","distance","allDistances","existingDescriptor","err","descriptorA","descriptorB","euclideanDistance","toFixed","confidence","compErr","sort","a","b","message","getAllFaces","entries","map","userData","updateFaceDescriptor","_existingData$info","existingData","getFaceDetailsFromFirebase","now","saveFaceToFirebaseById","getFaceFromFirebaseById"],"sources":["D:/Movies/Aniket/test2/test/src/services/firebaseFaceService.js"],"sourcesContent":["import { ref, set, get, remove, serverTimestamp } from \"firebase/database\";\r\nimport { rtdb } from \"../firebase/config\";\r\nimport * as faceapi from 'face-api.js';\r\n\r\n// Reference to faces in Firebase Realtime Database\r\nconst FACES_REF = \"faces\";\r\nconst DEBUG_REF = \"debug\";\r\n\r\n/**\r\n * Save face descriptor to Firebase Realtime Database using username as key\r\n * @param {string} userId - User ID (will be stored as additional data)\r\n * @param {string} username - Username to use as primary identifier \r\n * @param {Float32Array} descriptor - Face descriptor data\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const saveFaceToFirebase = async (userId, username, descriptor) => {\r\n  console.log(`Starting Firebase save process for user ${username} (ID: ${userId})...`);\r\n  \r\n  // Validate inputs\r\n  if (!username || !descriptor) {\r\n    console.error(\"Missing required parameters for saving face data\");\r\n    return false;\r\n  }\r\n  \r\n  // Sanitize username to create a valid Firebase key\r\n  const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n  \r\n  // Validate Firebase connection\r\n  if (!rtdb) {\r\n    console.error(\"Firebase Realtime Database not initialized\");\r\n    return false;\r\n  }\r\n  \r\n  try {\r\n    console.log(`RTDB URL: ${rtdb.app.options.databaseURL}`);\r\n    \r\n    // First run a basic write test\r\n    console.log(\"Running connectivity test...\");\r\n    const testRef = ref(rtdb, `${DEBUG_REF}/connectivity_test`);\r\n    await set(testRef, {\r\n      timestamp: new Date().toISOString(),\r\n      client: navigator.userAgent,\r\n      success: true\r\n    });\r\n    console.log(\"✅ Test write successful\");\r\n    \r\n    // Convert descriptor to array\r\n    console.log(\"Preparing descriptor data...\");\r\n    const descriptorArray = Array.from(descriptor);\r\n    \r\n    // Define path and create ref - using username as the key\r\n    const path = `${FACES_REF}/${safeUsername}`;\r\n    console.log(`Writing to path: ${path}`);\r\n    \r\n    // Write metadata first\r\n    await set(ref(rtdb, `${path}/metadata`), {\r\n      userId: userId, // Store userId as a reference\r\n      username: username,\r\n      descriptorLength: descriptorArray.length,\r\n      browser: navigator.userAgent.split(' ')[0],\r\n      userAgent: navigator.userAgent,\r\n      descriptorSample: descriptorArray.slice(0, 3) // Store sample of first 3 values\r\n    });\r\n    console.log(\"✅ Metadata written\");\r\n    \r\n    // Then write descriptor in batches of 20\r\n    const BATCH_SIZE = 20;\r\n    for (let i = 0; i < descriptorArray.length; i += BATCH_SIZE) {\r\n      const batch = descriptorArray.slice(i, i + BATCH_SIZE);\r\n      await set(ref(rtdb, `${path}/descriptor_part_${i/BATCH_SIZE}`), batch);\r\n    }\r\n    \r\n    // Finally write the basic info\r\n    await set(ref(rtdb, `${path}/info`), {\r\n      userId,\r\n      username,\r\n      timestamp: new Date().toISOString(),\r\n      parts: Math.ceil(descriptorArray.length / BATCH_SIZE)\r\n    });\r\n    \r\n    console.log(\"✅ All data written successfully\");\r\n    \r\n    // Verify data was written\r\n    const snapshot = await get(ref(rtdb, `${path}/info`));\r\n    if (snapshot.exists()) {\r\n      console.log(\"✅ Verification successful\");\r\n      return true;\r\n    } else {\r\n      console.error(\"❌ Verification failed - data not found after write\");\r\n      return false;\r\n    }\r\n  } catch (error) {\r\n    console.error(\"❌ Error saving face data to Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get face descriptor from Firebase by username\r\n * @param {string} username - Username\r\n * @returns {Promise<Float32Array|null>} Face descriptor or null if not found\r\n */\r\nexport const getFaceFromFirebase = async (username) => {\r\n  try {\r\n    if (!username) {\r\n      console.error(\"Username is required to get face data\");\r\n      return null;\r\n    }\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    \r\n    // Check if we have the full descriptor in one piece\r\n    const fullPath = `${FACES_REF}/${safeUsername}`;\r\n    const fullSnapshot = await get(ref(rtdb, fullPath));\r\n    \r\n    if (!fullSnapshot.exists()) {\r\n      console.log(`No data found for username ${username}`);\r\n      return null;\r\n    }\r\n    \r\n    const data = fullSnapshot.val();\r\n    \r\n    // Check if we have a simple descriptor array\r\n    if (data && data.descriptor) {\r\n      console.log(`Single-part descriptor found for ${username}`);\r\n      return new Float32Array(data.descriptor);\r\n    }\r\n    \r\n    // Check if we have multi-part descriptor\r\n    if (data && data.info && data.info.parts) {\r\n      console.log(`Multi-part descriptor found for ${username} (${data.info.parts} parts)`);\r\n      \r\n      // Assemble descriptor from parts\r\n      const descriptorParts = [];\r\n      for (let i = 0; i < data.info.parts; i++) {\r\n        const partKey = `descriptor_part_${i}`;\r\n        if (data[partKey]) {\r\n          descriptorParts.push(...data[partKey]);\r\n        }\r\n      }\r\n      \r\n      if (descriptorParts.length > 0) {\r\n        return new Float32Array(descriptorParts);\r\n      }\r\n    }\r\n    \r\n    console.log(`Data found for ${username} but no valid descriptor`);\r\n    return null;\r\n  } catch (error) {\r\n    console.error(\"Error getting face from Firebase:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Remove face descriptor from Firebase by username\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const removeFaceFromFirebase = async (username) => {\r\n  try {\r\n    if (!username) {\r\n      console.error(\"Username is required to remove face data\");\r\n      return false;\r\n    }\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\r\n    await remove(faceRef);\r\n    \r\n    console.log(`Face descriptor for ${username} removed from Firebase`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error removing face from Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if username has face data in Firebase\r\n * @param {string} username - Username\r\n * @returns {Promise<boolean>} Whether face data exists\r\n */\r\nexport const hasFaceInFirebase = async (username) => {\r\n  try {\r\n    if (!username) return false;\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\r\n    const snapshot = await get(faceRef);\r\n    \r\n    return snapshot.exists();\r\n  } catch (error) {\r\n    console.error(\"Error checking face in Firebase:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if a face descriptor already exists in the database under a different username\r\n * @param {Float32Array} descriptor - Face descriptor to check\r\n * @param {string} currentUsername - Username to exclude from the check\r\n * @returns {Promise<{exists: boolean, username: string|null}>} Result with exists flag and username if found\r\n */\r\nexport const checkFaceExists = async (descriptor, currentUsername) => {\r\n  try {\r\n    if (!descriptor) {\r\n      console.warn(\"No descriptor provided to checkFaceExists\");\r\n      return { exists: false, username: null };\r\n    }\r\n    \r\n    console.log(`Checking if face already exists (exclude username: ${currentUsername})`);\r\n    \r\n    // Make sure rtdb is initialized\r\n    if (!rtdb) {\r\n      console.warn(\"Firebase Realtime Database not initialized, skipping face check\");\r\n      return { exists: false, username: null, error: \"Database not initialized\" };\r\n    }\r\n    \r\n    try {\r\n      // Get all usernames from the database\r\n      const facesRef = ref(rtdb, FACES_REF);\r\n      const snapshot = await get(facesRef);\r\n      \r\n      if (!snapshot.exists()) {\r\n        console.log(\"No faces found in database, skipping comparison\");\r\n        return { exists: false, username: null };\r\n      }\r\n      \r\n      const data = snapshot.val();\r\n      if (!data) {\r\n        console.log(\"Snapshot exists but data is null\");\r\n        return { exists: false, username: null };\r\n      }\r\n      \r\n      const allUsernames = Object.keys(data);\r\n      if (allUsernames.length === 0) {\r\n        console.log(\"No usernames found in data\");\r\n        return { exists: false, username: null };\r\n      }\r\n      \r\n      console.log(`Found ${allUsernames.length} faces in database`);\r\n      \r\n      // Rest of the function remains unchanged\r\n      // ...existing code...\r\n      \r\n      // Threshold for face matching (adjust based on your requirements)\r\n      // Lower value = stricter matching, higher value = more lenient\r\n      const MATCH_THRESHOLD = 0.4; // Default threshold (stricter)\r\n      const POSSIBLE_MATCH_THRESHOLD = 0.6; // For possible matches (more lenient)\r\n      \r\n      const currentUsernameNormalized = currentUsername?.replace(/[.#$/[\\]]/g, '_');\r\n      let bestMatch = { username: null, distance: 1.0 };\r\n      \r\n      // Track all distances for debugging\r\n      const allDistances = [];\r\n      \r\n      // Check against each existing face\r\n      for (const username of allUsernames) {\r\n        // Skip the current username we're registering with\r\n        if (username === currentUsernameNormalized) {\r\n          continue;\r\n        }\r\n        \r\n        // Get the descriptor for this username\r\n        let existingDescriptor;\r\n        try {\r\n          existingDescriptor = await getFaceFromFirebase(username);\r\n          if (!existingDescriptor) {\r\n            console.log(`No descriptor found for username: ${username}`);\r\n            continue;\r\n          }\r\n        } catch (err) {\r\n          console.warn(`Error getting descriptor for ${username}:`, err);\r\n          continue;\r\n        }\r\n        \r\n        try {\r\n          // Normalize descriptors to ensure they're Float32Array\r\n          const descriptorA = descriptor instanceof Float32Array ? descriptor : new Float32Array(descriptor);\r\n          const descriptorB = existingDescriptor instanceof Float32Array ? \r\n            existingDescriptor : new Float32Array(existingDescriptor);\r\n          \r\n          // Calculate the similarity distance between faces\r\n          const distance = faceapi.euclideanDistance(descriptorA, descriptorB);\r\n          \r\n          // Track all distances for debugging\r\n          allDistances.push({ username, distance });\r\n          \r\n          // Keep track of the best match\r\n          if (distance < bestMatch.distance) {\r\n            bestMatch = { username, distance };\r\n          }\r\n          \r\n          // Log this comparison\r\n          console.log(`Face comparison with ${username}: Distance=${distance.toFixed(3)}`);\r\n          \r\n          // If the distance is below the threshold, it's likely the same person\r\n          if (distance < MATCH_THRESHOLD) {\r\n            console.log(`MATCH FOUND! Username: ${username}, Distance: ${distance}`);\r\n            return { \r\n              exists: true, \r\n              username: username,\r\n              distance: distance,\r\n              confidence: 'high'\r\n            };\r\n          }\r\n        } catch (compErr) {\r\n          console.warn(`Error comparing with ${username}:`, compErr);\r\n          continue;\r\n        }\r\n      }\r\n      \r\n      // Sort all distances for clearer debugging\r\n      allDistances.sort((a, b) => a.distance - b.distance);\r\n      console.log(\"All face distances:\", allDistances);\r\n      \r\n      // If we didn't find a definite match but have a possible match\r\n      if (bestMatch.username && bestMatch.distance < POSSIBLE_MATCH_THRESHOLD) {\r\n        console.log(`Possible match found: ${bestMatch.username} with distance ${bestMatch.distance}`);\r\n        return {\r\n          exists: true,\r\n          username: bestMatch.username,\r\n          distance: bestMatch.distance,\r\n          confidence: 'medium'\r\n        };\r\n      }\r\n      \r\n      console.log(\"No matching face found\");\r\n      return { exists: false, username: null };\r\n      \r\n    } catch (err) {\r\n      console.warn(\"Error during face checking:\", err);\r\n      // Return no match if there's an error, don't block the registration\r\n      return { exists: false, username: null, error: err.message };\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error checking if face exists:\", error);\r\n    return { exists: false, username: null, error: error.message };\r\n  }\r\n};\r\n\r\n/**\r\n * Get all faces from Firebase for comparison\r\n * @returns {Promise<Array>} Array of face data objects\r\n */\r\nexport const getAllFaces = async () => {\r\n  try {\r\n    const facesRef = ref(rtdb, FACES_REF);\r\n    const snapshot = await get(facesRef);\r\n    \r\n    if (!snapshot.exists()) return [];\r\n    \r\n    const data = snapshot.val();\r\n    return Object.entries(data).map(([username, userData]) => {\r\n      return {\r\n        username,\r\n        ...userData\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Error getting all faces:\", error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Update face descriptor for an existing username\r\n * @param {string} username - Username to update\r\n * @param {Float32Array} descriptor - New face descriptor\r\n * @returns {Promise<boolean>} Success status\r\n */\r\nexport const updateFaceDescriptor = async (username, descriptor) => {\r\n  // Simply use the same function to save - it will overwrite existing data\r\n  try {\r\n    if (!username || !descriptor) {\r\n      console.error(\"Missing required parameters for updating face data\");\r\n      return false;\r\n    }\r\n    \r\n    // Get the existing data first to preserve any other fields\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const existingData = await getFaceDetailsFromFirebase(safeUsername);\r\n    const userId = existingData?.info?.userId || `user_${Date.now()}`; \r\n    \r\n    console.log(`Updating face descriptor for username: ${username} with userId: ${userId}`);\r\n    \r\n    // Use the main save function which will overwrite existing data\r\n    return await saveFaceToFirebase(userId, username, descriptor);\r\n  } catch (error) {\r\n    console.error(\"Error updating face descriptor:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get face details from Firebase (not just descriptor)\r\n * @param {string} username - Username\r\n * @returns {Promise<Object|null>} Full face data or null if not found\r\n */\r\nexport const getFaceDetailsFromFirebase = async (username) => {\r\n  try {\r\n    if (!username) return null;\r\n    \r\n    // Sanitize username for Firebase\r\n    const safeUsername = username.replace(/[.#$/[\\]]/g, '_');\r\n    const faceRef = ref(rtdb, `${FACES_REF}/${safeUsername}`);\r\n    const snapshot = await get(faceRef);\r\n    \r\n    return snapshot.exists() ? snapshot.val() : null;\r\n  } catch (error) {\r\n    console.error(\"Error getting face details:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Keep the old user ID based methods for backward compatibility\r\n// But mark them as deprecated\r\n\r\n/**\r\n * @deprecated Use username-based methods instead\r\n */\r\nexport const saveFaceToFirebaseById = async (userId, descriptor) => {\r\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\r\n  // ...existing code...\r\n};\r\n\r\n/**\r\n * @deprecated Use username-based methods instead\r\n */\r\nexport const getFaceFromFirebaseById = async (userId) => {\r\n  console.warn(\"This method is deprecated. Use username-based methods instead.\");\r\n  // ...existing code...\r\n};\r\n"],"mappings":"AAAA,SAASA,GAAG,EAAEC,GAAG,EAAEC,GAAG,EAAEC,MAAM,EAAEC,eAAe,QAAQ,mBAAmB;AAC1E,SAASC,IAAI,QAAQ,oBAAoB;AACzC,OAAO,KAAKC,OAAO,MAAM,aAAa;;AAEtC;AACA,MAAMC,SAAS,GAAG,OAAO;AACzB,MAAMC,SAAS,GAAG,OAAO;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAG,MAAAA,CAAOC,MAAM,EAAEC,QAAQ,EAAEC,UAAU,KAAK;EACxEC,OAAO,CAACC,GAAG,CAAC,2CAA2CH,QAAQ,SAASD,MAAM,MAAM,CAAC;;EAErF;EACA,IAAI,CAACC,QAAQ,IAAI,CAACC,UAAU,EAAE;IAC5BC,OAAO,CAACE,KAAK,CAAC,kDAAkD,CAAC;IACjE,OAAO,KAAK;EACd;;EAEA;EACA,MAAMC,YAAY,GAAGL,QAAQ,CAACM,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;;EAExD;EACA,IAAI,CAACZ,IAAI,EAAE;IACTQ,OAAO,CAACE,KAAK,CAAC,4CAA4C,CAAC;IAC3D,OAAO,KAAK;EACd;EAEA,IAAI;IACFF,OAAO,CAACC,GAAG,CAAC,aAAaT,IAAI,CAACa,GAAG,CAACC,OAAO,CAACC,WAAW,EAAE,CAAC;;IAExD;IACAP,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;IAC3C,MAAMO,OAAO,GAAGrB,GAAG,CAACK,IAAI,EAAE,GAAGG,SAAS,oBAAoB,CAAC;IAC3D,MAAMP,GAAG,CAACoB,OAAO,EAAE;MACjBC,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;MACnCC,MAAM,EAAEC,SAAS,CAACC,SAAS;MAC3BC,OAAO,EAAE;IACX,CAAC,CAAC;IACFf,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;;IAEtC;IACAD,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;IAC3C,MAAMe,eAAe,GAAGC,KAAK,CAACC,IAAI,CAACnB,UAAU,CAAC;;IAE9C;IACA,MAAMoB,IAAI,GAAG,GAAGzB,SAAS,IAAIS,YAAY,EAAE;IAC3CH,OAAO,CAACC,GAAG,CAAC,oBAAoBkB,IAAI,EAAE,CAAC;;IAEvC;IACA,MAAM/B,GAAG,CAACD,GAAG,CAACK,IAAI,EAAE,GAAG2B,IAAI,WAAW,CAAC,EAAE;MACvCtB,MAAM,EAAEA,MAAM;MAAE;MAChBC,QAAQ,EAAEA,QAAQ;MAClBsB,gBAAgB,EAAEJ,eAAe,CAACK,MAAM;MACxCC,OAAO,EAAET,SAAS,CAACC,SAAS,CAACS,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC1CT,SAAS,EAAED,SAAS,CAACC,SAAS;MAC9BU,gBAAgB,EAAER,eAAe,CAACS,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAChD,CAAC,CAAC;IACFzB,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;;IAEjC;IACA,MAAMyB,UAAU,GAAG,EAAE;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,eAAe,CAACK,MAAM,EAAEM,CAAC,IAAID,UAAU,EAAE;MAC3D,MAAME,KAAK,GAAGZ,eAAe,CAACS,KAAK,CAACE,CAAC,EAAEA,CAAC,GAAGD,UAAU,CAAC;MACtD,MAAMtC,GAAG,CAACD,GAAG,CAACK,IAAI,EAAE,GAAG2B,IAAI,oBAAoBQ,CAAC,GAACD,UAAU,EAAE,CAAC,EAAEE,KAAK,CAAC;IACxE;;IAEA;IACA,MAAMxC,GAAG,CAACD,GAAG,CAACK,IAAI,EAAE,GAAG2B,IAAI,OAAO,CAAC,EAAE;MACnCtB,MAAM;MACNC,QAAQ;MACRW,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;MACnCkB,KAAK,EAAEC,IAAI,CAACC,IAAI,CAACf,eAAe,CAACK,MAAM,GAAGK,UAAU;IACtD,CAAC,CAAC;IAEF1B,OAAO,CAACC,GAAG,CAAC,iCAAiC,CAAC;;IAE9C;IACA,MAAM+B,QAAQ,GAAG,MAAM3C,GAAG,CAACF,GAAG,CAACK,IAAI,EAAE,GAAG2B,IAAI,OAAO,CAAC,CAAC;IACrD,IAAIa,QAAQ,CAACC,MAAM,CAAC,CAAC,EAAE;MACrBjC,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;MACxC,OAAO,IAAI;IACb,CAAC,MAAM;MACLD,OAAO,CAACE,KAAK,CAAC,oDAAoD,CAAC;MACnE,OAAO,KAAK;IACd;EACF,CAAC,CAAC,OAAOA,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;IAC7D,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMgC,mBAAmB,GAAG,MAAOpC,QAAQ,IAAK;EACrD,IAAI;IACF,IAAI,CAACA,QAAQ,EAAE;MACbE,OAAO,CAACE,KAAK,CAAC,uCAAuC,CAAC;MACtD,OAAO,IAAI;IACb;;IAEA;IACA,MAAMC,YAAY,GAAGL,QAAQ,CAACM,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;;IAExD;IACA,MAAM+B,QAAQ,GAAG,GAAGzC,SAAS,IAAIS,YAAY,EAAE;IAC/C,MAAMiC,YAAY,GAAG,MAAM/C,GAAG,CAACF,GAAG,CAACK,IAAI,EAAE2C,QAAQ,CAAC,CAAC;IAEnD,IAAI,CAACC,YAAY,CAACH,MAAM,CAAC,CAAC,EAAE;MAC1BjC,OAAO,CAACC,GAAG,CAAC,8BAA8BH,QAAQ,EAAE,CAAC;MACrD,OAAO,IAAI;IACb;IAEA,MAAMuC,IAAI,GAAGD,YAAY,CAACE,GAAG,CAAC,CAAC;;IAE/B;IACA,IAAID,IAAI,IAAIA,IAAI,CAACtC,UAAU,EAAE;MAC3BC,OAAO,CAACC,GAAG,CAAC,oCAAoCH,QAAQ,EAAE,CAAC;MAC3D,OAAO,IAAIyC,YAAY,CAACF,IAAI,CAACtC,UAAU,CAAC;IAC1C;;IAEA;IACA,IAAIsC,IAAI,IAAIA,IAAI,CAACG,IAAI,IAAIH,IAAI,CAACG,IAAI,CAACX,KAAK,EAAE;MACxC7B,OAAO,CAACC,GAAG,CAAC,mCAAmCH,QAAQ,KAAKuC,IAAI,CAACG,IAAI,CAACX,KAAK,SAAS,CAAC;;MAErF;MACA,MAAMY,eAAe,GAAG,EAAE;MAC1B,KAAK,IAAId,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,IAAI,CAACG,IAAI,CAACX,KAAK,EAAEF,CAAC,EAAE,EAAE;QACxC,MAAMe,OAAO,GAAG,mBAAmBf,CAAC,EAAE;QACtC,IAAIU,IAAI,CAACK,OAAO,CAAC,EAAE;UACjBD,eAAe,CAACE,IAAI,CAAC,GAAGN,IAAI,CAACK,OAAO,CAAC,CAAC;QACxC;MACF;MAEA,IAAID,eAAe,CAACpB,MAAM,GAAG,CAAC,EAAE;QAC9B,OAAO,IAAIkB,YAAY,CAACE,eAAe,CAAC;MAC1C;IACF;IAEAzC,OAAO,CAACC,GAAG,CAAC,kBAAkBH,QAAQ,0BAA0B,CAAC;IACjE,OAAO,IAAI;EACb,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;IACzD,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM0C,sBAAsB,GAAG,MAAO9C,QAAQ,IAAK;EACxD,IAAI;IACF,IAAI,CAACA,QAAQ,EAAE;MACbE,OAAO,CAACE,KAAK,CAAC,0CAA0C,CAAC;MACzD,OAAO,KAAK;IACd;;IAEA;IACA,MAAMC,YAAY,GAAGL,QAAQ,CAACM,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;IACxD,MAAMyC,OAAO,GAAG1D,GAAG,CAACK,IAAI,EAAE,GAAGE,SAAS,IAAIS,YAAY,EAAE,CAAC;IACzD,MAAMb,MAAM,CAACuD,OAAO,CAAC;IAErB7C,OAAO,CAACC,GAAG,CAAC,uBAAuBH,QAAQ,wBAAwB,CAAC;IACpE,OAAO,IAAI;EACb,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;IAC1D,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM4C,iBAAiB,GAAG,MAAOhD,QAAQ,IAAK;EACnD,IAAI;IACF,IAAI,CAACA,QAAQ,EAAE,OAAO,KAAK;;IAE3B;IACA,MAAMK,YAAY,GAAGL,QAAQ,CAACM,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;IACxD,MAAMyC,OAAO,GAAG1D,GAAG,CAACK,IAAI,EAAE,GAAGE,SAAS,IAAIS,YAAY,EAAE,CAAC;IACzD,MAAM6B,QAAQ,GAAG,MAAM3C,GAAG,CAACwD,OAAO,CAAC;IAEnC,OAAOb,QAAQ,CAACC,MAAM,CAAC,CAAC;EAC1B,CAAC,CAAC,OAAO/B,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IACxD,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM6C,eAAe,GAAG,MAAAA,CAAOhD,UAAU,EAAEiD,eAAe,KAAK;EACpE,IAAI;IACF,IAAI,CAACjD,UAAU,EAAE;MACfC,OAAO,CAACiD,IAAI,CAAC,2CAA2C,CAAC;MACzD,OAAO;QAAEhB,MAAM,EAAE,KAAK;QAAEnC,QAAQ,EAAE;MAAK,CAAC;IAC1C;IAEAE,OAAO,CAACC,GAAG,CAAC,sDAAsD+C,eAAe,GAAG,CAAC;;IAErF;IACA,IAAI,CAACxD,IAAI,EAAE;MACTQ,OAAO,CAACiD,IAAI,CAAC,iEAAiE,CAAC;MAC/E,OAAO;QAAEhB,MAAM,EAAE,KAAK;QAAEnC,QAAQ,EAAE,IAAI;QAAEI,KAAK,EAAE;MAA2B,CAAC;IAC7E;IAEA,IAAI;MACF;MACA,MAAMgD,QAAQ,GAAG/D,GAAG,CAACK,IAAI,EAAEE,SAAS,CAAC;MACrC,MAAMsC,QAAQ,GAAG,MAAM3C,GAAG,CAAC6D,QAAQ,CAAC;MAEpC,IAAI,CAAClB,QAAQ,CAACC,MAAM,CAAC,CAAC,EAAE;QACtBjC,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;QAC9D,OAAO;UAAEgC,MAAM,EAAE,KAAK;UAAEnC,QAAQ,EAAE;QAAK,CAAC;MAC1C;MAEA,MAAMuC,IAAI,GAAGL,QAAQ,CAACM,GAAG,CAAC,CAAC;MAC3B,IAAI,CAACD,IAAI,EAAE;QACTrC,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;QAC/C,OAAO;UAAEgC,MAAM,EAAE,KAAK;UAAEnC,QAAQ,EAAE;QAAK,CAAC;MAC1C;MAEA,MAAMqD,YAAY,GAAGC,MAAM,CAACC,IAAI,CAAChB,IAAI,CAAC;MACtC,IAAIc,YAAY,CAAC9B,MAAM,KAAK,CAAC,EAAE;QAC7BrB,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;QACzC,OAAO;UAAEgC,MAAM,EAAE,KAAK;UAAEnC,QAAQ,EAAE;QAAK,CAAC;MAC1C;MAEAE,OAAO,CAACC,GAAG,CAAC,SAASkD,YAAY,CAAC9B,MAAM,oBAAoB,CAAC;;MAE7D;MACA;;MAEA;MACA;MACA,MAAMiC,eAAe,GAAG,GAAG,CAAC,CAAC;MAC7B,MAAMC,wBAAwB,GAAG,GAAG,CAAC,CAAC;;MAEtC,MAAMC,yBAAyB,GAAGR,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE5C,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;MAC7E,IAAIqD,SAAS,GAAG;QAAE3D,QAAQ,EAAE,IAAI;QAAE4D,QAAQ,EAAE;MAAI,CAAC;;MAEjD;MACA,MAAMC,YAAY,GAAG,EAAE;;MAEvB;MACA,KAAK,MAAM7D,QAAQ,IAAIqD,YAAY,EAAE;QACnC;QACA,IAAIrD,QAAQ,KAAK0D,yBAAyB,EAAE;UAC1C;QACF;;QAEA;QACA,IAAII,kBAAkB;QACtB,IAAI;UACFA,kBAAkB,GAAG,MAAM1B,mBAAmB,CAACpC,QAAQ,CAAC;UACxD,IAAI,CAAC8D,kBAAkB,EAAE;YACvB5D,OAAO,CAACC,GAAG,CAAC,qCAAqCH,QAAQ,EAAE,CAAC;YAC5D;UACF;QACF,CAAC,CAAC,OAAO+D,GAAG,EAAE;UACZ7D,OAAO,CAACiD,IAAI,CAAC,gCAAgCnD,QAAQ,GAAG,EAAE+D,GAAG,CAAC;UAC9D;QACF;QAEA,IAAI;UACF;UACA,MAAMC,WAAW,GAAG/D,UAAU,YAAYwC,YAAY,GAAGxC,UAAU,GAAG,IAAIwC,YAAY,CAACxC,UAAU,CAAC;UAClG,MAAMgE,WAAW,GAAGH,kBAAkB,YAAYrB,YAAY,GAC5DqB,kBAAkB,GAAG,IAAIrB,YAAY,CAACqB,kBAAkB,CAAC;;UAE3D;UACA,MAAMF,QAAQ,GAAGjE,OAAO,CAACuE,iBAAiB,CAACF,WAAW,EAAEC,WAAW,CAAC;;UAEpE;UACAJ,YAAY,CAAChB,IAAI,CAAC;YAAE7C,QAAQ;YAAE4D;UAAS,CAAC,CAAC;;UAEzC;UACA,IAAIA,QAAQ,GAAGD,SAAS,CAACC,QAAQ,EAAE;YACjCD,SAAS,GAAG;cAAE3D,QAAQ;cAAE4D;YAAS,CAAC;UACpC;;UAEA;UACA1D,OAAO,CAACC,GAAG,CAAC,wBAAwBH,QAAQ,cAAc4D,QAAQ,CAACO,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;;UAEhF;UACA,IAAIP,QAAQ,GAAGJ,eAAe,EAAE;YAC9BtD,OAAO,CAACC,GAAG,CAAC,0BAA0BH,QAAQ,eAAe4D,QAAQ,EAAE,CAAC;YACxE,OAAO;cACLzB,MAAM,EAAE,IAAI;cACZnC,QAAQ,EAAEA,QAAQ;cAClB4D,QAAQ,EAAEA,QAAQ;cAClBQ,UAAU,EAAE;YACd,CAAC;UACH;QACF,CAAC,CAAC,OAAOC,OAAO,EAAE;UAChBnE,OAAO,CAACiD,IAAI,CAAC,wBAAwBnD,QAAQ,GAAG,EAAEqE,OAAO,CAAC;UAC1D;QACF;MACF;;MAEA;MACAR,YAAY,CAACS,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACX,QAAQ,GAAGY,CAAC,CAACZ,QAAQ,CAAC;MACpD1D,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAE0D,YAAY,CAAC;;MAEhD;MACA,IAAIF,SAAS,CAAC3D,QAAQ,IAAI2D,SAAS,CAACC,QAAQ,GAAGH,wBAAwB,EAAE;QACvEvD,OAAO,CAACC,GAAG,CAAC,yBAAyBwD,SAAS,CAAC3D,QAAQ,kBAAkB2D,SAAS,CAACC,QAAQ,EAAE,CAAC;QAC9F,OAAO;UACLzB,MAAM,EAAE,IAAI;UACZnC,QAAQ,EAAE2D,SAAS,CAAC3D,QAAQ;UAC5B4D,QAAQ,EAAED,SAAS,CAACC,QAAQ;UAC5BQ,UAAU,EAAE;QACd,CAAC;MACH;MAEAlE,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC;MACrC,OAAO;QAAEgC,MAAM,EAAE,KAAK;QAAEnC,QAAQ,EAAE;MAAK,CAAC;IAE1C,CAAC,CAAC,OAAO+D,GAAG,EAAE;MACZ7D,OAAO,CAACiD,IAAI,CAAC,6BAA6B,EAAEY,GAAG,CAAC;MAChD;MACA,OAAO;QAAE5B,MAAM,EAAE,KAAK;QAAEnC,QAAQ,EAAE,IAAI;QAAEI,KAAK,EAAE2D,GAAG,CAACU;MAAQ,CAAC;IAC9D;EACF,CAAC,CAAC,OAAOrE,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACtD,OAAO;MAAE+B,MAAM,EAAE,KAAK;MAAEnC,QAAQ,EAAE,IAAI;MAAEI,KAAK,EAAEA,KAAK,CAACqE;IAAQ,CAAC;EAChE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAG,MAAAA,CAAA,KAAY;EACrC,IAAI;IACF,MAAMtB,QAAQ,GAAG/D,GAAG,CAACK,IAAI,EAAEE,SAAS,CAAC;IACrC,MAAMsC,QAAQ,GAAG,MAAM3C,GAAG,CAAC6D,QAAQ,CAAC;IAEpC,IAAI,CAAClB,QAAQ,CAACC,MAAM,CAAC,CAAC,EAAE,OAAO,EAAE;IAEjC,MAAMI,IAAI,GAAGL,QAAQ,CAACM,GAAG,CAAC,CAAC;IAC3B,OAAOc,MAAM,CAACqB,OAAO,CAACpC,IAAI,CAAC,CAACqC,GAAG,CAAC,CAAC,CAAC5E,QAAQ,EAAE6E,QAAQ,CAAC,KAAK;MACxD,OAAO;QACL7E,QAAQ;QACR,GAAG6E;MACL,CAAC;IACH,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOzE,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;IAChD,OAAO,EAAE;EACX;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM0E,oBAAoB,GAAG,MAAAA,CAAO9E,QAAQ,EAAEC,UAAU,KAAK;EAClE;EACA,IAAI;IAAA,IAAA8E,kBAAA;IACF,IAAI,CAAC/E,QAAQ,IAAI,CAACC,UAAU,EAAE;MAC5BC,OAAO,CAACE,KAAK,CAAC,oDAAoD,CAAC;MACnE,OAAO,KAAK;IACd;;IAEA;IACA,MAAMC,YAAY,GAAGL,QAAQ,CAACM,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;IACxD,MAAM0E,YAAY,GAAG,MAAMC,0BAA0B,CAAC5E,YAAY,CAAC;IACnE,MAAMN,MAAM,GAAG,CAAAiF,YAAY,aAAZA,YAAY,wBAAAD,kBAAA,GAAZC,YAAY,CAAEtC,IAAI,cAAAqC,kBAAA,uBAAlBA,kBAAA,CAAoBhF,MAAM,KAAI,QAAQa,IAAI,CAACsE,GAAG,CAAC,CAAC,EAAE;IAEjEhF,OAAO,CAACC,GAAG,CAAC,0CAA0CH,QAAQ,iBAAiBD,MAAM,EAAE,CAAC;;IAExF;IACA,OAAO,MAAMD,kBAAkB,CAACC,MAAM,EAAEC,QAAQ,EAAEC,UAAU,CAAC;EAC/D,CAAC,CAAC,OAAOG,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvD,OAAO,KAAK;EACd;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAM6E,0BAA0B,GAAG,MAAOjF,QAAQ,IAAK;EAC5D,IAAI;IACF,IAAI,CAACA,QAAQ,EAAE,OAAO,IAAI;;IAE1B;IACA,MAAMK,YAAY,GAAGL,QAAQ,CAACM,OAAO,CAAC,YAAY,EAAE,GAAG,CAAC;IACxD,MAAMyC,OAAO,GAAG1D,GAAG,CAACK,IAAI,EAAE,GAAGE,SAAS,IAAIS,YAAY,EAAE,CAAC;IACzD,MAAM6B,QAAQ,GAAG,MAAM3C,GAAG,CAACwD,OAAO,CAAC;IAEnC,OAAOb,QAAQ,CAACC,MAAM,CAAC,CAAC,GAAGD,QAAQ,CAACM,GAAG,CAAC,CAAC,GAAG,IAAI;EAClD,CAAC,CAAC,OAAOpC,KAAK,EAAE;IACdF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,OAAO,MAAM+E,sBAAsB,GAAG,MAAAA,CAAOpF,MAAM,EAAEE,UAAU,KAAK;EAClEC,OAAO,CAACiD,IAAI,CAAC,gEAAgE,CAAC;EAC9E;AACF,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMiC,uBAAuB,GAAG,MAAOrF,MAAM,IAAK;EACvDG,OAAO,CAACiD,IAAI,CAAC,gEAAgE,CAAC;EAC9E;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}