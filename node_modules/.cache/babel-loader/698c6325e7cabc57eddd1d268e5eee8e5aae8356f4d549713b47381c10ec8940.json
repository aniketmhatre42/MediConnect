{"ast":null,"code":"import * as faceapi from 'face-api.js';\n\n/**\r\n * Compares a face descriptor with all stored face descriptors to check for matches\r\n * @param {Float32Array} newDescriptor - The new face descriptor to check\r\n * @param {Array} existingUsers - Array of stored user data with face descriptors\r\n * @param {number} threshold - Similarity threshold (lower = stricter matching)\r\n * @returns {Object|null} Matching user or null if no match found\r\n */\nexport const findMatchingFace = (newDescriptor, existingUsers, threshold = 0.5) => {\n  if (!newDescriptor || !existingUsers || !existingUsers.length) {\n    return null;\n  }\n  console.log(`Checking new face against ${existingUsers.length} existing faces`);\n  let bestMatch = {\n    distance: 1,\n    user: null\n  };\n  for (const user of existingUsers) {\n    try {\n      // Skip if no descriptor\n      if (!user.descriptor) continue;\n\n      // Convert stored descriptor to Float32Array\n      const storedDescriptor = new Float32Array(user.descriptor);\n\n      // Calculate euclidean distance (lower = more similar)\n      const distance = faceapi.euclideanDistance(newDescriptor, storedDescriptor);\n      console.log(`Distance for ${user.username}: ${distance.toFixed(4)}`);\n\n      // Update best match if this is better\n      if (distance < bestMatch.distance) {\n        bestMatch = {\n          distance,\n          user\n        };\n      }\n\n      // If we found a very close match, return immediately\n      if (distance < threshold) {\n        console.log(`Match found! User: ${user.username}, distance: ${distance.toFixed(4)}`);\n        return {\n          user,\n          distance,\n          username: user.username,\n          confidence: 1 - distance // Convert distance to confidence (0-1)\n        };\n      }\n    } catch (error) {\n      console.error(`Error comparing with user ${user.username}:`, error);\n    }\n  }\n\n  // If best match is close enough, return it\n  if (bestMatch.distance < threshold * 1.2) {\n    var _bestMatch$user, _bestMatch$user2;\n    console.log(`Possible match found: ${(_bestMatch$user = bestMatch.user) === null || _bestMatch$user === void 0 ? void 0 : _bestMatch$user.username}, distance: ${bestMatch.distance.toFixed(4)}`);\n    return {\n      user: bestMatch.user,\n      distance: bestMatch.distance,\n      username: (_bestMatch$user2 = bestMatch.user) === null || _bestMatch$user2 === void 0 ? void 0 : _bestMatch$user2.username,\n      confidence: 1 - bestMatch.distance // Convert distance to confidence (0-1)\n    };\n  }\n  console.log(\"No matching face found\");\n  return null;\n};\n\n/**\r\n * Format face match confidence as a percentage string\r\n * @param {number} confidence - Match confidence (0-1)\r\n * @returns {string} Formatted percentage\r\n */\nexport const formatMatchConfidence = confidence => {\n  return `${Math.round(confidence * 100)}%`;\n};","map":{"version":3,"names":["faceapi","findMatchingFace","newDescriptor","existingUsers","threshold","length","console","log","bestMatch","distance","user","descriptor","storedDescriptor","Float32Array","euclideanDistance","username","toFixed","confidence","error","_bestMatch$user","_bestMatch$user2","formatMatchConfidence","Math","round"],"sources":["D:/Movies/Aniket/test2/test/src/utils/faceUtils.js"],"sourcesContent":["import * as faceapi from 'face-api.js';\r\n\r\n/**\r\n * Compares a face descriptor with all stored face descriptors to check for matches\r\n * @param {Float32Array} newDescriptor - The new face descriptor to check\r\n * @param {Array} existingUsers - Array of stored user data with face descriptors\r\n * @param {number} threshold - Similarity threshold (lower = stricter matching)\r\n * @returns {Object|null} Matching user or null if no match found\r\n */\r\nexport const findMatchingFace = (newDescriptor, existingUsers, threshold = 0.5) => {\r\n  if (!newDescriptor || !existingUsers || !existingUsers.length) {\r\n    return null;\r\n  }\r\n\r\n  console.log(`Checking new face against ${existingUsers.length} existing faces`);\r\n  \r\n  let bestMatch = { distance: 1, user: null };\r\n  \r\n  for (const user of existingUsers) {\r\n    try {\r\n      // Skip if no descriptor\r\n      if (!user.descriptor) continue;\r\n      \r\n      // Convert stored descriptor to Float32Array\r\n      const storedDescriptor = new Float32Array(user.descriptor);\r\n      \r\n      // Calculate euclidean distance (lower = more similar)\r\n      const distance = faceapi.euclideanDistance(newDescriptor, storedDescriptor);\r\n      \r\n      console.log(`Distance for ${user.username}: ${distance.toFixed(4)}`);\r\n      \r\n      // Update best match if this is better\r\n      if (distance < bestMatch.distance) {\r\n        bestMatch = { distance, user };\r\n      }\r\n      \r\n      // If we found a very close match, return immediately\r\n      if (distance < threshold) {\r\n        console.log(`Match found! User: ${user.username}, distance: ${distance.toFixed(4)}`);\r\n        return {\r\n          user,\r\n          distance,\r\n          username: user.username,\r\n          confidence: 1 - distance // Convert distance to confidence (0-1)\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error comparing with user ${user.username}:`, error);\r\n    }\r\n  }\r\n  \r\n  // If best match is close enough, return it\r\n  if (bestMatch.distance < threshold * 1.2) {\r\n    console.log(`Possible match found: ${bestMatch.user?.username}, distance: ${bestMatch.distance.toFixed(4)}`);\r\n    return {\r\n      user: bestMatch.user,\r\n      distance: bestMatch.distance,\r\n      username: bestMatch.user?.username,\r\n      confidence: 1 - bestMatch.distance // Convert distance to confidence (0-1)\r\n    };\r\n  }\r\n  \r\n  console.log(\"No matching face found\");\r\n  return null;\r\n};\r\n\r\n/**\r\n * Format face match confidence as a percentage string\r\n * @param {number} confidence - Match confidence (0-1)\r\n * @returns {string} Formatted percentage\r\n */\r\nexport const formatMatchConfidence = (confidence) => {\r\n  return `${Math.round(confidence * 100)}%`;\r\n};\r\n"],"mappings":"AAAA,OAAO,KAAKA,OAAO,MAAM,aAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,GAAGA,CAACC,aAAa,EAAEC,aAAa,EAAEC,SAAS,GAAG,GAAG,KAAK;EACjF,IAAI,CAACF,aAAa,IAAI,CAACC,aAAa,IAAI,CAACA,aAAa,CAACE,MAAM,EAAE;IAC7D,OAAO,IAAI;EACb;EAEAC,OAAO,CAACC,GAAG,CAAC,6BAA6BJ,aAAa,CAACE,MAAM,iBAAiB,CAAC;EAE/E,IAAIG,SAAS,GAAG;IAAEC,QAAQ,EAAE,CAAC;IAAEC,IAAI,EAAE;EAAK,CAAC;EAE3C,KAAK,MAAMA,IAAI,IAAIP,aAAa,EAAE;IAChC,IAAI;MACF;MACA,IAAI,CAACO,IAAI,CAACC,UAAU,EAAE;;MAEtB;MACA,MAAMC,gBAAgB,GAAG,IAAIC,YAAY,CAACH,IAAI,CAACC,UAAU,CAAC;;MAE1D;MACA,MAAMF,QAAQ,GAAGT,OAAO,CAACc,iBAAiB,CAACZ,aAAa,EAAEU,gBAAgB,CAAC;MAE3EN,OAAO,CAACC,GAAG,CAAC,gBAAgBG,IAAI,CAACK,QAAQ,KAAKN,QAAQ,CAACO,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;;MAEpE;MACA,IAAIP,QAAQ,GAAGD,SAAS,CAACC,QAAQ,EAAE;QACjCD,SAAS,GAAG;UAAEC,QAAQ;UAAEC;QAAK,CAAC;MAChC;;MAEA;MACA,IAAID,QAAQ,GAAGL,SAAS,EAAE;QACxBE,OAAO,CAACC,GAAG,CAAC,sBAAsBG,IAAI,CAACK,QAAQ,eAAeN,QAAQ,CAACO,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;QACpF,OAAO;UACLN,IAAI;UACJD,QAAQ;UACRM,QAAQ,EAAEL,IAAI,CAACK,QAAQ;UACvBE,UAAU,EAAE,CAAC,GAAGR,QAAQ,CAAC;QAC3B,CAAC;MACH;IACF,CAAC,CAAC,OAAOS,KAAK,EAAE;MACdZ,OAAO,CAACY,KAAK,CAAC,6BAA6BR,IAAI,CAACK,QAAQ,GAAG,EAAEG,KAAK,CAAC;IACrE;EACF;;EAEA;EACA,IAAIV,SAAS,CAACC,QAAQ,GAAGL,SAAS,GAAG,GAAG,EAAE;IAAA,IAAAe,eAAA,EAAAC,gBAAA;IACxCd,OAAO,CAACC,GAAG,CAAC,0BAAAY,eAAA,GAAyBX,SAAS,CAACE,IAAI,cAAAS,eAAA,uBAAdA,eAAA,CAAgBJ,QAAQ,eAAeP,SAAS,CAACC,QAAQ,CAACO,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;IAC5G,OAAO;MACLN,IAAI,EAAEF,SAAS,CAACE,IAAI;MACpBD,QAAQ,EAAED,SAAS,CAACC,QAAQ;MAC5BM,QAAQ,GAAAK,gBAAA,GAAEZ,SAAS,CAACE,IAAI,cAAAU,gBAAA,uBAAdA,gBAAA,CAAgBL,QAAQ;MAClCE,UAAU,EAAE,CAAC,GAAGT,SAAS,CAACC,QAAQ,CAAC;IACrC,CAAC;EACH;EAEAH,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC;EACrC,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMc,qBAAqB,GAAIJ,UAAU,IAAK;EACnD,OAAO,GAAGK,IAAI,CAACC,KAAK,CAACN,UAAU,GAAG,GAAG,CAAC,GAAG;AAC3C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}