{"ast":null,"code":"import * as faceapi from 'face-api.js';\n\n/**\r\n * Compares a face descriptor with all stored face descriptors to check for matches\r\n * @param {Float32Array} newDescriptor - The new face descriptor to check\r\n * @param {Array} existingUsers - Array of stored user data with face descriptors\r\n * @param {number} threshold - Similarity threshold (lower = stricter matching)\r\n * @returns {Object|null} Matching user or null if no match found\r\n */\nexport const findMatchingFace = (newDescriptor, existingUsers, threshold = 0.4) => {\n  if (!newDescriptor || !existingUsers || !existingUsers.length) {\n    return null;\n  }\n  console.log(`Checking new face against ${existingUsers.length} existing faces`);\n  let bestMatch = {\n    distance: 1,\n    user: null\n  };\n  for (const user of existingUsers) {\n    try {\n      // Skip if no descriptor or if it's not a valid array\n      if (!user.descriptor || !Array.isArray(user.descriptor) || user.descriptor.length === 0) {\n        console.log(`Skipping user ${user.username || user.userId} - invalid descriptor`);\n        continue;\n      }\n\n      // Convert stored descriptor to Float32Array\n      const storedDescriptor = new Float32Array(user.descriptor);\n      if (storedDescriptor.length !== newDescriptor.length) {\n        console.log(`Descriptor length mismatch for ${user.username}: ${storedDescriptor.length} vs ${newDescriptor.length}`);\n        continue;\n      }\n\n      // Calculate euclidean distance (lower = more similar)\n      const distance = faceapi.euclideanDistance(newDescriptor, storedDescriptor);\n\n      // Don't log the username - just the distance and threshold for security\n      console.log(`Face match check - distance: ${distance.toFixed(4)}, threshold: ${threshold}`);\n\n      // Update best match if this is better\n      if (distance < bestMatch.distance) {\n        bestMatch = {\n          distance,\n          user\n        };\n      }\n\n      // If we found a match below threshold, return immediately\n      if (distance < threshold) {\n        console.log(`ðŸ‘¤ MATCH FOUND! Distance: ${distance.toFixed(4)}`);\n        return {\n          user,\n          distance,\n          username: user.username,\n          confidence: 1 - distance // Convert distance to confidence (0-1)\n        };\n      }\n    } catch (error) {\n      console.error(`Error during face comparison:`, error);\n    }\n  }\n\n  // If best match is close but above threshold, still return as potential match\n  if (bestMatch.distance < threshold * 1.5) {\n    var _bestMatch$user;\n    console.log(`Possible match found. Distance: ${bestMatch.distance.toFixed(4)}`);\n    return {\n      user: bestMatch.user,\n      distance: bestMatch.distance,\n      username: (_bestMatch$user = bestMatch.user) === null || _bestMatch$user === void 0 ? void 0 : _bestMatch$user.username,\n      confidence: 1 - bestMatch.distance,\n      isPotentialMatch: true // Flag that it's a looser match\n    };\n  }\n  console.log(\"No matching face found\");\n  return null;\n};\n\n/**\r\n * Format face match confidence as a percentage string\r\n * @param {number} confidence - Match confidence (0-1)\r\n * @returns {string} Formatted percentage\r\n */\nexport const formatMatchConfidence = confidence => {\n  return `${Math.round(confidence * 100)}%`;\n};","map":{"version":3,"names":["faceapi","findMatchingFace","newDescriptor","existingUsers","threshold","length","console","log","bestMatch","distance","user","descriptor","Array","isArray","username","userId","storedDescriptor","Float32Array","euclideanDistance","toFixed","confidence","error","_bestMatch$user","isPotentialMatch","formatMatchConfidence","Math","round"],"sources":["D:/Movies/Aniket/test2/test/src/utils/faceUtils.js"],"sourcesContent":["import * as faceapi from 'face-api.js';\r\n\r\n/**\r\n * Compares a face descriptor with all stored face descriptors to check for matches\r\n * @param {Float32Array} newDescriptor - The new face descriptor to check\r\n * @param {Array} existingUsers - Array of stored user data with face descriptors\r\n * @param {number} threshold - Similarity threshold (lower = stricter matching)\r\n * @returns {Object|null} Matching user or null if no match found\r\n */\r\nexport const findMatchingFace = (newDescriptor, existingUsers, threshold = 0.4) => {\r\n  if (!newDescriptor || !existingUsers || !existingUsers.length) {\r\n    return null;\r\n  }\r\n\r\n  console.log(`Checking new face against ${existingUsers.length} existing faces`);\r\n  \r\n  let bestMatch = { distance: 1, user: null };\r\n  \r\n  for (const user of existingUsers) {\r\n    try {\r\n      // Skip if no descriptor or if it's not a valid array\r\n      if (!user.descriptor || !Array.isArray(user.descriptor) || user.descriptor.length === 0) {\r\n        console.log(`Skipping user ${user.username || user.userId} - invalid descriptor`);\r\n        continue;\r\n      }\r\n      \r\n      // Convert stored descriptor to Float32Array\r\n      const storedDescriptor = new Float32Array(user.descriptor);\r\n      \r\n      if (storedDescriptor.length !== newDescriptor.length) {\r\n        console.log(`Descriptor length mismatch for ${user.username}: ${storedDescriptor.length} vs ${newDescriptor.length}`);\r\n        continue;\r\n      }\r\n      \r\n      // Calculate euclidean distance (lower = more similar)\r\n      const distance = faceapi.euclideanDistance(newDescriptor, storedDescriptor);\r\n      \r\n      // Don't log the username - just the distance and threshold for security\r\n      console.log(`Face match check - distance: ${distance.toFixed(4)}, threshold: ${threshold}`);\r\n      \r\n      // Update best match if this is better\r\n      if (distance < bestMatch.distance) {\r\n        bestMatch = { distance, user };\r\n      }\r\n      \r\n      // If we found a match below threshold, return immediately\r\n      if (distance < threshold) {\r\n        console.log(`ðŸ‘¤ MATCH FOUND! Distance: ${distance.toFixed(4)}`);\r\n        return {\r\n          user,\r\n          distance,\r\n          username: user.username,\r\n          confidence: 1 - distance // Convert distance to confidence (0-1)\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error during face comparison:`, error);\r\n    }\r\n  }\r\n  \r\n  // If best match is close but above threshold, still return as potential match\r\n  if (bestMatch.distance < threshold * 1.5) {\r\n    console.log(`Possible match found. Distance: ${bestMatch.distance.toFixed(4)}`);\r\n    return {\r\n      user: bestMatch.user,\r\n      distance: bestMatch.distance,\r\n      username: bestMatch.user?.username,\r\n      confidence: 1 - bestMatch.distance,\r\n      isPotentialMatch: true // Flag that it's a looser match\r\n    };\r\n  }\r\n  \r\n  console.log(\"No matching face found\");\r\n  return null;\r\n};\r\n\r\n/**\r\n * Format face match confidence as a percentage string\r\n * @param {number} confidence - Match confidence (0-1)\r\n * @returns {string} Formatted percentage\r\n */\r\nexport const formatMatchConfidence = (confidence) => {\r\n  return `${Math.round(confidence * 100)}%`;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}