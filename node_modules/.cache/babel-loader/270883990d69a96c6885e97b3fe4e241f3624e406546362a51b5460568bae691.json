{"ast":null,"code":"import { ref, set, get, update, push, onValue, onDisconnect, serverTimestamp, remove } from \"firebase/database\";\nimport { rtdb } from \"../firebase/config\";\n\n/**\r\n * Create a persistent user session in Firebase RTDB\r\n * @param {string} userId - User ID\r\n * @param {Object} sessionData - Session data to store\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const createUserSession = async (userId, sessionData) => {\n  try {\n    if (!userId || !sessionData) {\n      console.error(\"Invalid user data for session creation\");\n      return false;\n    }\n\n    // Create a new session under this user\n    const sessionRef = ref(rtdb, `sessions/${userId}/${Date.now()}`);\n\n    // Add server timestamp and status\n    const enhancedSessionData = {\n      ...sessionData,\n      createdAt: serverTimestamp(),\n      lastActive: serverTimestamp(),\n      active: true,\n      device: sessionData.device || navigator.userAgent\n    };\n    await set(sessionRef, enhancedSessionData);\n\n    // Setup presence system\n    const connectedRef = ref(rtdb, '.info/connected');\n    onValue(connectedRef, snapshot => {\n      if (snapshot.val() === true) {\n        // When we disconnect, update the lastSeen indicator and set active to false\n        onDisconnect(sessionRef).update({\n          lastActive: serverTimestamp(),\n          active: false\n        });\n\n        // Also update the lastActive timestamp while connected\n        const updateInterval = setInterval(() => {\n          update(sessionRef, {\n            lastActive: serverTimestamp()\n          });\n        }, 60000); // Update every minute\n\n        // Clear interval on disconnection\n        onDisconnect(sessionRef).update({\n          _updateIntervalCleared: true\n        });\n      }\n    });\n    console.log(\"User session created successfully\");\n    return true;\n  } catch (error) {\n    console.error(\"Error creating user session:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Get current user from session storage or local storage\r\n * @returns {Object|null} User object or null if not logged in\r\n */\nexport const getLoggedInUser = () => {\n  // Check if this is a regular user (face auth)\n  const authenticated = sessionStorage.getItem('authenticated') === 'true';\n  const userId = sessionStorage.getItem('userId');\n  const username = sessionStorage.getItem('username');\n\n  // For face auth login (primary method)\n  if (authenticated && username) {\n    return {\n      id: userId || `user_${Date.now()}`,\n      role: 'user',\n      username: username,\n      loginMethod: 'face'\n    };\n  }\n\n  // If specifically looking for an Asha Worker login\n  if (userId && sessionStorage.getItem('userRole') === 'ashaWorker') {\n    return {\n      id: userId,\n      role: 'ashaWorker',\n      username: sessionStorage.getItem('workerName') || sessionStorage.getItem('userEmail') || 'Asha Worker'\n    };\n  }\n\n  // Check local storage as fallback (for persistent auth)\n  try {\n    const localUser = localStorage.getItem('user');\n    if (localUser) {\n      const userData = JSON.parse(localUser);\n      return {\n        id: userData.id || userData.userId,\n        username: userData.username || 'User',\n        role: userData.role || 'user'\n      };\n    }\n  } catch (error) {\n    console.error(\"Error parsing user data from localStorage:\", error);\n  }\n  return null;\n};\n\n/**\r\n * Check if user is authenticated\r\n * @returns {boolean} True if user is logged in\r\n */\nexport const isAuthenticated = () => {\n  return getLoggedInUser() !== null;\n};\n\n/**\r\n * Check if user is authenticated as an Asha worker\r\n * @returns {boolean} True if logged in as an Asha worker\r\n */\nexport const isAshaWorker = () => {\n  const user = getLoggedInUser();\n  return user !== null && user.role === 'ashaWorker';\n};\n\n/**\r\n * Get the current user's display name\r\n * @returns {string} Username or default text if not logged in\r\n */\nexport const getDisplayName = () => {\n  const user = getLoggedInUser();\n  return user ? user.username : 'Guest';\n};\n\n/**\r\n * Log out the current user by clearing session and local storage\r\n * Also update Firebase RTDB session to inactive\r\n * @returns {Promise<boolean>} - Success status\r\n */\nexport const logoutUser = async () => {\n  try {\n    // Get user ID before clearing storage\n    const userId = sessionStorage.getItem('userId');\n\n    // If we have a user ID, mark Firebase session as inactive\n    if (userId) {\n      try {\n        // Get all user sessions\n        const sessionsRef = ref(rtdb, `sessions/${userId}`);\n        const snapshot = await get(sessionsRef);\n        if (snapshot.exists()) {\n          // Find the active session(s) and mark them as inactive\n          const sessions = snapshot.val();\n          const updates = {};\n          Object.keys(sessions).forEach(sessionId => {\n            if (sessions[sessionId].active) {\n              updates[`sessions/${userId}/${sessionId}/active`] = false;\n              updates[`sessions/${userId}/${sessionId}/logoutTime`] = serverTimestamp();\n            }\n          });\n          if (Object.keys(updates).length > 0) {\n            await update(ref(rtdb), updates);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error updating Firebase session:\", error);\n      }\n    }\n\n    // Clear session storage\n    sessionStorage.removeItem('authenticated');\n    sessionStorage.removeItem('userId');\n    sessionStorage.removeItem('username');\n    sessionStorage.removeItem('userEmail');\n    sessionStorage.removeItem('loginMethod');\n    sessionStorage.removeItem('loginTime');\n    sessionStorage.removeItem('userRole');\n    sessionStorage.removeItem('workerName');\n    sessionStorage.removeItem('workerDistrict');\n\n    // Clear localStorage data\n    localStorage.removeItem('user');\n    return true;\n  } catch (error) {\n    console.error(\"Error during logout:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["ref","set","get","update","push","onValue","onDisconnect","serverTimestamp","remove","rtdb","createUserSession","userId","sessionData","console","error","sessionRef","Date","now","enhancedSessionData","createdAt","lastActive","active","device","navigator","userAgent","connectedRef","snapshot","val","updateInterval","setInterval","_updateIntervalCleared","log","getLoggedInUser","authenticated","sessionStorage","getItem","username","id","role","loginMethod","localUser","localStorage","userData","JSON","parse","isAuthenticated","isAshaWorker","user","getDisplayName","logoutUser","sessionsRef","exists","sessions","updates","Object","keys","forEach","sessionId","length","removeItem"],"sources":["D:/Movies/Aniket/test2/test/src/utils/authUtils.js"],"sourcesContent":["import { ref, set, get, update, push, onValue, onDisconnect, serverTimestamp, remove } from \"firebase/database\";\r\nimport { rtdb } from \"../firebase/config\";\r\n\r\n/**\r\n * Create a persistent user session in Firebase RTDB\r\n * @param {string} userId - User ID\r\n * @param {Object} sessionData - Session data to store\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const createUserSession = async (userId, sessionData) => {\r\n  try {\r\n    if (!userId || !sessionData) {\r\n      console.error(\"Invalid user data for session creation\");\r\n      return false;\r\n    }\r\n    \r\n    // Create a new session under this user\r\n    const sessionRef = ref(rtdb, `sessions/${userId}/${Date.now()}`);\r\n    \r\n    // Add server timestamp and status\r\n    const enhancedSessionData = {\r\n      ...sessionData,\r\n      createdAt: serverTimestamp(),\r\n      lastActive: serverTimestamp(),\r\n      active: true,\r\n      device: sessionData.device || navigator.userAgent\r\n    };\r\n    \r\n    await set(sessionRef, enhancedSessionData);\r\n    \r\n    // Setup presence system\r\n    const connectedRef = ref(rtdb, '.info/connected');\r\n    onValue(connectedRef, (snapshot) => {\r\n      if (snapshot.val() === true) {\r\n        // When we disconnect, update the lastSeen indicator and set active to false\r\n        onDisconnect(sessionRef).update({\r\n          lastActive: serverTimestamp(),\r\n          active: false\r\n        });\r\n        \r\n        // Also update the lastActive timestamp while connected\r\n        const updateInterval = setInterval(() => {\r\n          update(sessionRef, {\r\n            lastActive: serverTimestamp()\r\n          });\r\n        }, 60000); // Update every minute\r\n        \r\n        // Clear interval on disconnection\r\n        onDisconnect(sessionRef).update({\r\n          _updateIntervalCleared: true\r\n        });\r\n      }\r\n    });\r\n    \r\n    console.log(\"User session created successfully\");\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error creating user session:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get current user from session storage or local storage\r\n * @returns {Object|null} User object or null if not logged in\r\n */\r\nexport const getLoggedInUser = () => {\r\n  // Check if this is a regular user (face auth)\r\n  const authenticated = sessionStorage.getItem('authenticated') === 'true';\r\n  const userId = sessionStorage.getItem('userId');\r\n  const username = sessionStorage.getItem('username');\r\n  \r\n  // For face auth login (primary method)\r\n  if (authenticated && username) {\r\n    return {\r\n      id: userId || `user_${Date.now()}`,\r\n      role: 'user',\r\n      username: username,\r\n      loginMethod: 'face'\r\n    };\r\n  }\r\n  \r\n  // If specifically looking for an Asha Worker login\r\n  if (userId && sessionStorage.getItem('userRole') === 'ashaWorker') {\r\n    return {\r\n      id: userId,\r\n      role: 'ashaWorker',\r\n      username: sessionStorage.getItem('workerName') || \r\n               sessionStorage.getItem('userEmail') || \r\n               'Asha Worker'\r\n    };\r\n  }\r\n\r\n  // Check local storage as fallback (for persistent auth)\r\n  try {\r\n    const localUser = localStorage.getItem('user');\r\n    if (localUser) {\r\n      const userData = JSON.parse(localUser);\r\n      return {\r\n        id: userData.id || userData.userId,\r\n        username: userData.username || 'User',\r\n        role: userData.role || 'user'\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error parsing user data from localStorage:\", error);\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n/**\r\n * Check if user is authenticated\r\n * @returns {boolean} True if user is logged in\r\n */\r\nexport const isAuthenticated = () => {\r\n  return getLoggedInUser() !== null;\r\n};\r\n\r\n/**\r\n * Check if user is authenticated as an Asha worker\r\n * @returns {boolean} True if logged in as an Asha worker\r\n */\r\nexport const isAshaWorker = () => {\r\n  const user = getLoggedInUser();\r\n  return user !== null && user.role === 'ashaWorker';\r\n};\r\n\r\n/**\r\n * Get the current user's display name\r\n * @returns {string} Username or default text if not logged in\r\n */\r\nexport const getDisplayName = () => {\r\n  const user = getLoggedInUser();\r\n  return user ? user.username : 'Guest';\r\n};\r\n\r\n/**\r\n * Log out the current user by clearing session and local storage\r\n * Also update Firebase RTDB session to inactive\r\n * @returns {Promise<boolean>} - Success status\r\n */\r\nexport const logoutUser = async () => {\r\n  try {\r\n    // Get user ID before clearing storage\r\n    const userId = sessionStorage.getItem('userId');\r\n    \r\n    // If we have a user ID, mark Firebase session as inactive\r\n    if (userId) {\r\n      try {\r\n        // Get all user sessions\r\n        const sessionsRef = ref(rtdb, `sessions/${userId}`);\r\n        const snapshot = await get(sessionsRef);\r\n        \r\n        if (snapshot.exists()) {\r\n          // Find the active session(s) and mark them as inactive\r\n          const sessions = snapshot.val();\r\n          const updates = {};\r\n          \r\n          Object.keys(sessions).forEach(sessionId => {\r\n            if (sessions[sessionId].active) {\r\n              updates[`sessions/${userId}/${sessionId}/active`] = false;\r\n              updates[`sessions/${userId}/${sessionId}/logoutTime`] = serverTimestamp();\r\n            }\r\n          });\r\n          \r\n          if (Object.keys(updates).length > 0) {\r\n            await update(ref(rtdb), updates);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error updating Firebase session:\", error);\r\n      }\r\n    }\r\n    \r\n    // Clear session storage\r\n    sessionStorage.removeItem('authenticated');\r\n    sessionStorage.removeItem('userId');\r\n    sessionStorage.removeItem('username');\r\n    sessionStorage.removeItem('userEmail');\r\n    sessionStorage.removeItem('loginMethod');\r\n    sessionStorage.removeItem('loginTime');\r\n    sessionStorage.removeItem('userRole');\r\n    sessionStorage.removeItem('workerName');\r\n    sessionStorage.removeItem('workerDistrict');\r\n    \r\n    // Clear localStorage data\r\n    localStorage.removeItem('user');\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"Error during logout:\", error);\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}