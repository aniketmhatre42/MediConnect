{"ast":null,"code":"import { saveFaceToFirebase, getFaceFromFirebase, removeFaceFromFirebase, hasFaceInFirebase } from './firebaseFaceService';\n\n// Local storage service for face data management\n\n// Base directory name (for naming convention only)\nconst FACE_DATA_DIR = 'face_data';\nconst STORAGE_KEY = 'face_descriptors';\n\n/**\r\n * Saves face descriptor data to Firebase and localStorage as fallback\r\n * @param {string} userId - The unique user ID\r\n * @param {Float32Array} descriptor - The face descriptor data\r\n * @returns {Promise<boolean>} - Whether the save was successful\r\n */\nexport const saveFaceDescriptor = async (userId, descriptor) => {\n  try {\n    console.log(`Starting face descriptor save process for user ${userId}`);\n\n    // First try to save to Firebase with a timeout\n    let firebaseSaved = false;\n    try {\n      const firebasePromise = saveFaceToFirebase(userId, descriptor);\n      // Add a timeout to prevent hanging\n      const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Firebase save operation timed out')), 5000));\n      firebaseSaved = await Promise.race([firebasePromise, timeoutPromise]);\n      if (firebaseSaved) {\n        console.log(\"Successfully saved to Firebase\");\n      }\n    } catch (fbError) {\n      console.warn(\"Firebase save failed or timed out, continuing with localStorage:\", fbError);\n    }\n\n    // Always save to localStorage as a fallback/backup\n    console.log(\"Saving to localStorage as backup\");\n    const descriptorArray = Array.from(descriptor);\n    storeLocalCopy(userId, descriptorArray);\n    return true; // Consider overall operation successful if local storage worked\n  } catch (error) {\n    console.error('Error saving face descriptor:', error);\n    return false;\n  }\n};\n\n/**\r\n * Loads face descriptor data, trying Firebase first then falling back to localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Promise<Float32Array|null>} - The face descriptor or null if not found\r\n */\nexport const loadFaceDescriptor = async userId => {\n  try {\n    // Try to load from Firebase first\n    let descriptor = null;\n    try {\n      descriptor = await getFaceFromFirebase(userId);\n      if (descriptor) {\n        console.log(`Face descriptor for ${userId} loaded from Firebase`);\n        return descriptor;\n      }\n    } catch (fbError) {\n      console.warn(\"Failed to load from Firebase, trying localStorage:\", fbError);\n    }\n\n    // If not found in Firebase or error occurred, try localStorage\n    const localCopy = getLocalCopy(userId);\n    if (localCopy) {\n      console.log(`Face descriptor for ${userId} loaded from localStorage`);\n      return new Float32Array(localCopy);\n    }\n    console.log(`No face descriptor found for user ${userId}`);\n    return null;\n  } catch (error) {\n    console.error('Error loading face descriptor:', error);\n    return null;\n  }\n};\n\n/**\r\n * Stores the face data in localStorage\r\n * @param {string} userId - The unique user ID\r\n * @param {Array} descriptorArray - The face descriptor array\r\n */\nconst storeLocalCopy = (userId, descriptorArray) => {\n  try {\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n\n    // Check if this user already has a descriptor\n    const existingIndex = faceDescriptors.findIndex(item => item.userId === userId);\n    if (existingIndex >= 0) {\n      faceDescriptors[existingIndex].descriptor = descriptorArray;\n      faceDescriptors[existingIndex].timestamp = new Date().toISOString();\n      console.log(`Updated existing face descriptor for user ${userId} in localStorage`);\n    } else {\n      faceDescriptors.push({\n        userId,\n        descriptor: descriptorArray,\n        timestamp: new Date().toISOString()\n      });\n      console.log(`Added new face descriptor for user ${userId} to localStorage`);\n    }\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(faceDescriptors));\n  } catch (e) {\n    console.error('Error storing face data in localStorage:', e);\n    throw e;\n  }\n};\n\n/**\r\n * Gets a face descriptor from localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Array|null} - The descriptor array or null if not found\r\n */\nconst getLocalCopy = userId => {\n  try {\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n    const userFace = faceDescriptors.find(item => item.userId === userId);\n    return userFace ? userFace.descriptor : null;\n  } catch (e) {\n    console.error('Error getting face data from localStorage:', e);\n    return null;\n  }\n};\n\n/**\r\n * Removes a face descriptor from both Firebase and localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Promise<boolean>} - Whether the removal was successful\r\n */\nexport const removeFaceDescriptor = async userId => {\n  try {\n    // Try to remove from Firebase\n    let firebaseRemoved = false;\n    try {\n      firebaseRemoved = await removeFaceFromFirebase(userId);\n    } catch (fbError) {\n      console.warn(\"Failed to remove from Firebase:\", fbError);\n    }\n\n    // Always remove from localStorage\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n    const filteredDescriptors = faceDescriptors.filter(item => item.userId !== userId);\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(filteredDescriptors));\n    console.log(`Face descriptor for user ${userId} removed from storage`);\n    return firebaseRemoved || true; // Return true if either method worked\n  } catch (error) {\n    console.error('Error removing face descriptor:', error);\n    return false;\n  }\n};\n\n/**\r\n * Check if a user has stored face data (in either Firebase or localStorage)\r\n * @param {string} userId - The unique user ID\r\n * @returns {Promise<boolean>} - Whether the user has face data\r\n */\nexport const hasFaceDescriptor = async userId => {\n  try {\n    // Check Firebase first\n    try {\n      const inFirebase = await hasFaceInFirebase(userId);\n      if (inFirebase) return true;\n    } catch (fbError) {\n      console.warn(\"Failed to check Firebase for face data:\", fbError);\n    }\n\n    // Check localStorage as fallback\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n    return faceDescriptors.some(item => item.userId === userId);\n  } catch (error) {\n    console.error('Error checking for face descriptor:', error);\n    return false;\n  }\n};\n\n/**\r\n * Lists all user IDs with stored face descriptors (from localStorage)\r\n * @returns {Array<string>} - Array of user IDs\r\n */\nexport const listFaceUsers = () => {\n  try {\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\n    return faceDescriptors.map(item => item.userId);\n  } catch (error) {\n    console.error('Error listing face users:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["saveFaceToFirebase","getFaceFromFirebase","removeFaceFromFirebase","hasFaceInFirebase","FACE_DATA_DIR","STORAGE_KEY","saveFaceDescriptor","userId","descriptor","console","log","firebaseSaved","firebasePromise","timeoutPromise","Promise","_","reject","setTimeout","Error","race","fbError","warn","descriptorArray","Array","from","storeLocalCopy","error","loadFaceDescriptor","localCopy","getLocalCopy","Float32Array","faceDescriptors","JSON","parse","localStorage","getItem","existingIndex","findIndex","item","timestamp","Date","toISOString","push","setItem","stringify","e","userFace","find","removeFaceDescriptor","firebaseRemoved","filteredDescriptors","filter","hasFaceDescriptor","inFirebase","some","listFaceUsers","map"],"sources":["D:/Movies/Aniket/test2/test/src/services/localFaceStorage.js"],"sourcesContent":["import { \r\n  saveFaceToFirebase, \r\n  getFaceFromFirebase,\r\n  removeFaceFromFirebase,\r\n  hasFaceInFirebase\r\n} from './firebaseFaceService';\r\n\r\n// Local storage service for face data management\r\n\r\n// Base directory name (for naming convention only)\r\nconst FACE_DATA_DIR = 'face_data';\r\nconst STORAGE_KEY = 'face_descriptors';\r\n\r\n/**\r\n * Saves face descriptor data to Firebase and localStorage as fallback\r\n * @param {string} userId - The unique user ID\r\n * @param {Float32Array} descriptor - The face descriptor data\r\n * @returns {Promise<boolean>} - Whether the save was successful\r\n */\r\nexport const saveFaceDescriptor = async (userId, descriptor) => {\r\n  try {\r\n    console.log(`Starting face descriptor save process for user ${userId}`);\r\n    \r\n    // First try to save to Firebase with a timeout\r\n    let firebaseSaved = false;\r\n    try {\r\n      const firebasePromise = saveFaceToFirebase(userId, descriptor);\r\n      // Add a timeout to prevent hanging\r\n      const timeoutPromise = new Promise((_, reject) => \r\n        setTimeout(() => reject(new Error('Firebase save operation timed out')), 5000)\r\n      );\r\n      \r\n      firebaseSaved = await Promise.race([firebasePromise, timeoutPromise]);\r\n      if (firebaseSaved) {\r\n        console.log(\"Successfully saved to Firebase\");\r\n      }\r\n    } catch (fbError) {\r\n      console.warn(\"Firebase save failed or timed out, continuing with localStorage:\", fbError);\r\n    }\r\n    \r\n    // Always save to localStorage as a fallback/backup\r\n    console.log(\"Saving to localStorage as backup\");\r\n    const descriptorArray = Array.from(descriptor);\r\n    storeLocalCopy(userId, descriptorArray);\r\n    \r\n    return true; // Consider overall operation successful if local storage worked\r\n  } catch (error) {\r\n    console.error('Error saving face descriptor:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Loads face descriptor data, trying Firebase first then falling back to localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Promise<Float32Array|null>} - The face descriptor or null if not found\r\n */\r\nexport const loadFaceDescriptor = async (userId) => {\r\n  try {\r\n    // Try to load from Firebase first\r\n    let descriptor = null;\r\n    try {\r\n      descriptor = await getFaceFromFirebase(userId);\r\n      if (descriptor) {\r\n        console.log(`Face descriptor for ${userId} loaded from Firebase`);\r\n        return descriptor;\r\n      }\r\n    } catch (fbError) {\r\n      console.warn(\"Failed to load from Firebase, trying localStorage:\", fbError);\r\n    }\r\n    \r\n    // If not found in Firebase or error occurred, try localStorage\r\n    const localCopy = getLocalCopy(userId);\r\n    if (localCopy) {\r\n      console.log(`Face descriptor for ${userId} loaded from localStorage`);\r\n      return new Float32Array(localCopy);\r\n    }\r\n    \r\n    console.log(`No face descriptor found for user ${userId}`);\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error loading face descriptor:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stores the face data in localStorage\r\n * @param {string} userId - The unique user ID\r\n * @param {Array} descriptorArray - The face descriptor array\r\n */\r\nconst storeLocalCopy = (userId, descriptorArray) => {\r\n  try {\r\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\r\n    \r\n    // Check if this user already has a descriptor\r\n    const existingIndex = faceDescriptors.findIndex(item => item.userId === userId);\r\n    \r\n    if (existingIndex >= 0) {\r\n      faceDescriptors[existingIndex].descriptor = descriptorArray;\r\n      faceDescriptors[existingIndex].timestamp = new Date().toISOString();\r\n      console.log(`Updated existing face descriptor for user ${userId} in localStorage`);\r\n    } else {\r\n      faceDescriptors.push({\r\n        userId,\r\n        descriptor: descriptorArray,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      console.log(`Added new face descriptor for user ${userId} to localStorage`);\r\n    }\r\n    \r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(faceDescriptors));\r\n  } catch (e) {\r\n    console.error('Error storing face data in localStorage:', e);\r\n    throw e;\r\n  }\r\n};\r\n\r\n/**\r\n * Gets a face descriptor from localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Array|null} - The descriptor array or null if not found\r\n */\r\nconst getLocalCopy = (userId) => {\r\n  try {\r\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\r\n    const userFace = faceDescriptors.find(item => item.userId === userId);\r\n    return userFace ? userFace.descriptor : null;\r\n  } catch (e) {\r\n    console.error('Error getting face data from localStorage:', e);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Removes a face descriptor from both Firebase and localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Promise<boolean>} - Whether the removal was successful\r\n */\r\nexport const removeFaceDescriptor = async (userId) => {\r\n  try {\r\n    // Try to remove from Firebase\r\n    let firebaseRemoved = false;\r\n    try {\r\n      firebaseRemoved = await removeFaceFromFirebase(userId);\r\n    } catch (fbError) {\r\n      console.warn(\"Failed to remove from Firebase:\", fbError);\r\n    }\r\n    \r\n    // Always remove from localStorage\r\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\r\n    const filteredDescriptors = faceDescriptors.filter(item => item.userId !== userId);\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(filteredDescriptors));\r\n    \r\n    console.log(`Face descriptor for user ${userId} removed from storage`);\r\n    return firebaseRemoved || true; // Return true if either method worked\r\n  } catch (error) {\r\n    console.error('Error removing face descriptor:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if a user has stored face data (in either Firebase or localStorage)\r\n * @param {string} userId - The unique user ID\r\n * @returns {Promise<boolean>} - Whether the user has face data\r\n */\r\nexport const hasFaceDescriptor = async (userId) => {\r\n  try {\r\n    // Check Firebase first\r\n    try {\r\n      const inFirebase = await hasFaceInFirebase(userId);\r\n      if (inFirebase) return true;\r\n    } catch (fbError) {\r\n      console.warn(\"Failed to check Firebase for face data:\", fbError);\r\n    }\r\n    \r\n    // Check localStorage as fallback\r\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\r\n    return faceDescriptors.some(item => item.userId === userId);\r\n  } catch (error) {\r\n    console.error('Error checking for face descriptor:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Lists all user IDs with stored face descriptors (from localStorage)\r\n * @returns {Array<string>} - Array of user IDs\r\n */\r\nexport const listFaceUsers = () => {\r\n  try {\r\n    const faceDescriptors = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');\r\n    return faceDescriptors.map(item => item.userId);\r\n  } catch (error) {\r\n    console.error('Error listing face users:', error);\r\n    return [];\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}