{"ast":null,"code":"/**\r\n * Utility to help debug camera issues\r\n */\n\nexport const diagnoseCamera = async () => {\n  const report = {\n    browserInfo: getBrowserInfo(),\n    cameraSupport: checkCameraSupport(),\n    permissions: await checkCameraPermissions(),\n    devices: await listMediaDevices()\n  };\n  console.log(\"Camera diagnostics report:\", report);\n  return report;\n};\nfunction getBrowserInfo() {\n  return {\n    userAgent: navigator.userAgent,\n    vendor: navigator.vendor,\n    platform: navigator.platform,\n    language: navigator.language\n  };\n}\nfunction checkCameraSupport() {\n  return {\n    mediaDevicesSupported: !!navigator.mediaDevices,\n    getUserMediaSupported: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),\n    enumerateDevicesSupported: !!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices),\n    streamConstraintsSupported: !!(window.MediaStreamTrack && MediaStreamTrack.getSources)\n  };\n}\nasync function checkCameraPermissions() {\n  try {\n    // Query for camera permission state\n    const permissionStatus = await navigator.permissions.query({\n      name: 'camera'\n    });\n    return {\n      state: permissionStatus.state,\n      // 'granted', 'denied', or 'prompt'\n      permissionQuerySupported: true\n    };\n  } catch (error) {\n    // Permission query not supported\n    return {\n      state: 'unknown',\n      permissionQuerySupported: false,\n      error: error.message\n    };\n  }\n}\nasync function listMediaDevices() {\n  try {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n      return {\n        supported: false\n      };\n    }\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    return {\n      supported: true,\n      count: devices.length,\n      videoCameras: devices.filter(d => d.kind === 'videoinput').map(d => ({\n        deviceId: d.deviceId,\n        label: d.label || 'Unnamed camera',\n        groupId: d.groupId\n      }))\n    };\n  } catch (error) {\n    return {\n      supported: false,\n      error: error.message\n    };\n  }\n}\n\n/**\r\n * Tests the camera with current constraints\r\n * @returns {Promise<Object>} Test results\r\n */\nexport const testCameraWithConstraints = async (constraints = {\n  video: true\n}) => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n\n    // Analyze the stream tracks\n    const videoTracks = stream.getVideoTracks();\n    const trackInfo = videoTracks.map(track => ({\n      label: track.label,\n      enabled: track.enabled,\n      muted: track.muted,\n      readyState: track.readyState,\n      constraints: track.getConstraints(),\n      settings: track.getSettings()\n    }));\n\n    // Stop the stream\n    videoTracks.forEach(track => track.stop());\n    return {\n      success: true,\n      trackCount: videoTracks.length,\n      tracks: trackInfo\n    };\n  } catch (error) {\n    return {\n      success: false,\n      errorName: error.name,\n      errorMessage: error.message,\n      constraintName: error.constraintName\n    };\n  }\n};\n\n/**\r\n * Try to fix common camera issues automatically\r\n */\nexport const fixCameraIssues = async videoElement => {\n  if (!videoElement) return {\n    success: false,\n    message: \"No video element provided\"\n  };\n  try {\n    // 1. Check if browser is in a background tab (which might pause media)\n    if (document.hidden) {\n      return {\n        success: false,\n        message: \"Browser tab is not active. Please focus this tab.\"\n      };\n    }\n\n    // 2. Check if the video element is properly initialized\n    if (!videoElement.srcObject) {\n      return {\n        success: false,\n        message: \"Video source is not set. Try restarting the camera.\"\n      };\n    }\n\n    // 3. Try different constraints if current ones aren't working\n    const videoTracks = videoElement.srcObject.getVideoTracks();\n    if (!videoTracks || videoTracks.length === 0) {\n      // Try getting a lower quality stream\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          width: {\n            ideal: 320\n          },\n          height: {\n            ideal: 240\n          },\n          frameRate: {\n            max: 15\n          }\n        }\n      });\n      videoElement.srcObject = stream;\n      return {\n        success: true,\n        message: \"Applied lower quality video constraints\"\n      };\n    }\n\n    // 4. Check if track is ended or muted\n    const track = videoTracks[0];\n    if (track.readyState === 'ended') {\n      return {\n        success: false,\n        message: \"Video track has ended. Camera may be in use by another application.\"\n      };\n    }\n\n    // 5. Try restarting the track\n    if (track.stop && typeof track.stop === 'function') {\n      track.stop();\n    }\n    const newStream = await navigator.mediaDevices.getUserMedia({\n      video: true\n    });\n    videoElement.srcObject = newStream;\n    return {\n      success: true,\n      message: \"Camera restarted successfully\"\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Failed to fix camera: ${error.message}`\n    };\n  }\n};\n\n/**\r\n * Force a camera permission prompt to appear\r\n * @returns {Promise<Object>} - Permission status\r\n */\nexport const requestCameraPermission = async () => {\n  try {\n    var _permissionStatus;\n    // First try the Permissions API\n    let permissionStatus = null;\n    try {\n      permissionStatus = await navigator.permissions.query({\n        name: 'camera'\n      });\n      console.log(\"Initial permission status:\", permissionStatus.state);\n\n      // If permission is denied, we'll need getUserMedia to trigger a new prompt\n      if (permissionStatus.state === 'denied') {\n        console.log(\"Permission previously denied, trying to request again\");\n      }\n    } catch (err) {\n      console.log(\"Permissions API not supported:\", err);\n    }\n\n    // Now force a permission prompt using getUserMedia\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode: \"user\",\n        width: {\n          ideal: 640\n        },\n        height: {\n          ideal: 480\n        }\n      }\n    });\n\n    // Stop the stream immediately to release camera\n    stream.getTracks().forEach(track => track.stop());\n\n    // Check permission status again\n    if (navigator.permissions && navigator.permissions.query) {\n      permissionStatus = await navigator.permissions.query({\n        name: 'camera'\n      });\n    }\n    return {\n      success: true,\n      permissionGranted: true,\n      permissionState: ((_permissionStatus = permissionStatus) === null || _permissionStatus === void 0 ? void 0 : _permissionStatus.state) || 'granted',\n      message: \"Camera permission successfully requested\"\n    };\n  } catch (err) {\n    console.error(\"Error requesting camera permission:\", err);\n    return {\n      success: false,\n      permissionGranted: false,\n      error: err.name,\n      message: err.message,\n      isDenied: err.name === \"NotAllowedError\",\n      isNotFound: err.name === \"NotFoundError\"\n    };\n  }\n};","map":{"version":3,"names":["diagnoseCamera","report","browserInfo","getBrowserInfo","cameraSupport","checkCameraSupport","permissions","checkCameraPermissions","devices","listMediaDevices","console","log","userAgent","navigator","vendor","platform","language","mediaDevicesSupported","mediaDevices","getUserMediaSupported","getUserMedia","enumerateDevicesSupported","enumerateDevices","streamConstraintsSupported","window","MediaStreamTrack","getSources","permissionStatus","query","name","state","permissionQuerySupported","error","message","supported","count","length","videoCameras","filter","d","kind","map","deviceId","label","groupId","testCameraWithConstraints","constraints","video","stream","videoTracks","getVideoTracks","trackInfo","track","enabled","muted","readyState","getConstraints","settings","getSettings","forEach","stop","success","trackCount","tracks","errorName","errorMessage","constraintName","fixCameraIssues","videoElement","document","hidden","srcObject","width","ideal","height","frameRate","max","newStream","requestCameraPermission","_permissionStatus","err","facingMode","getTracks","permissionGranted","permissionState","isDenied","isNotFound"],"sources":["D:/Movies/Aniket/test2/test/src/utils/cameraDebugger.js"],"sourcesContent":["/**\r\n * Utility to help debug camera issues\r\n */\r\n\r\nexport const diagnoseCamera = async () => {\r\n  const report = {\r\n    browserInfo: getBrowserInfo(),\r\n    cameraSupport: checkCameraSupport(),\r\n    permissions: await checkCameraPermissions(),\r\n    devices: await listMediaDevices()\r\n  };\r\n  \r\n  console.log(\"Camera diagnostics report:\", report);\r\n  return report;\r\n};\r\n\r\nfunction getBrowserInfo() {\r\n  return {\r\n    userAgent: navigator.userAgent,\r\n    vendor: navigator.vendor,\r\n    platform: navigator.platform,\r\n    language: navigator.language\r\n  };\r\n}\r\n\r\nfunction checkCameraSupport() {\r\n  return {\r\n    mediaDevicesSupported: !!navigator.mediaDevices,\r\n    getUserMediaSupported: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),\r\n    enumerateDevicesSupported: !!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices),\r\n    streamConstraintsSupported: !!(window.MediaStreamTrack && MediaStreamTrack.getSources)\r\n  };\r\n}\r\n\r\nasync function checkCameraPermissions() {\r\n  try {\r\n    // Query for camera permission state\r\n    const permissionStatus = await navigator.permissions.query({ name: 'camera' });\r\n    return {\r\n      state: permissionStatus.state, // 'granted', 'denied', or 'prompt'\r\n      permissionQuerySupported: true\r\n    };\r\n  } catch (error) {\r\n    // Permission query not supported\r\n    return {\r\n      state: 'unknown',\r\n      permissionQuerySupported: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\nasync function listMediaDevices() {\r\n  try {\r\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\r\n      return { supported: false };\r\n    }\r\n    \r\n    const devices = await navigator.mediaDevices.enumerateDevices();\r\n    \r\n    return {\r\n      supported: true,\r\n      count: devices.length,\r\n      videoCameras: devices.filter(d => d.kind === 'videoinput').map(d => ({\r\n        deviceId: d.deviceId,\r\n        label: d.label || 'Unnamed camera',\r\n        groupId: d.groupId\r\n      }))\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      supported: false,\r\n      error: error.message\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Tests the camera with current constraints\r\n * @returns {Promise<Object>} Test results\r\n */\r\nexport const testCameraWithConstraints = async (constraints = { video: true }) => {\r\n  try {\r\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n    \r\n    // Analyze the stream tracks\r\n    const videoTracks = stream.getVideoTracks();\r\n    const trackInfo = videoTracks.map(track => ({\r\n      label: track.label,\r\n      enabled: track.enabled,\r\n      muted: track.muted,\r\n      readyState: track.readyState,\r\n      constraints: track.getConstraints(),\r\n      settings: track.getSettings()\r\n    }));\r\n    \r\n    // Stop the stream\r\n    videoTracks.forEach(track => track.stop());\r\n    \r\n    return {\r\n      success: true,\r\n      trackCount: videoTracks.length,\r\n      tracks: trackInfo\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      errorName: error.name,\r\n      errorMessage: error.message,\r\n      constraintName: error.constraintName\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Try to fix common camera issues automatically\r\n */\r\nexport const fixCameraIssues = async (videoElement) => {\r\n  if (!videoElement) return { success: false, message: \"No video element provided\" };\r\n  \r\n  try {\r\n    // 1. Check if browser is in a background tab (which might pause media)\r\n    if (document.hidden) {\r\n      return { \r\n        success: false, \r\n        message: \"Browser tab is not active. Please focus this tab.\" \r\n      };\r\n    }\r\n    \r\n    // 2. Check if the video element is properly initialized\r\n    if (!videoElement.srcObject) {\r\n      return { \r\n        success: false, \r\n        message: \"Video source is not set. Try restarting the camera.\" \r\n      };\r\n    }\r\n    \r\n    // 3. Try different constraints if current ones aren't working\r\n    const videoTracks = videoElement.srcObject.getVideoTracks();\r\n    if (!videoTracks || videoTracks.length === 0) {\r\n      // Try getting a lower quality stream\r\n      const stream = await navigator.mediaDevices.getUserMedia({\r\n        video: {\r\n          width: { ideal: 320 },\r\n          height: { ideal: 240 },\r\n          frameRate: { max: 15 }\r\n        }\r\n      });\r\n      \r\n      videoElement.srcObject = stream;\r\n      return {\r\n        success: true,\r\n        message: \"Applied lower quality video constraints\"\r\n      };\r\n    }\r\n    \r\n    // 4. Check if track is ended or muted\r\n    const track = videoTracks[0];\r\n    if (track.readyState === 'ended') {\r\n      return {\r\n        success: false,\r\n        message: \"Video track has ended. Camera may be in use by another application.\"\r\n      };\r\n    }\r\n    \r\n    // 5. Try restarting the track\r\n    if (track.stop && typeof track.stop === 'function') {\r\n      track.stop();\r\n    }\r\n    \r\n    const newStream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n    videoElement.srcObject = newStream;\r\n    \r\n    return {\r\n      success: true,\r\n      message: \"Camera restarted successfully\"\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      message: `Failed to fix camera: ${error.message}`\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Force a camera permission prompt to appear\r\n * @returns {Promise<Object>} - Permission status\r\n */\r\nexport const requestCameraPermission = async () => {\r\n  try {\r\n    // First try the Permissions API\r\n    let permissionStatus = null;\r\n    try {\r\n      permissionStatus = await navigator.permissions.query({ name: 'camera' });\r\n      console.log(\"Initial permission status:\", permissionStatus.state);\r\n      \r\n      // If permission is denied, we'll need getUserMedia to trigger a new prompt\r\n      if (permissionStatus.state === 'denied') {\r\n        console.log(\"Permission previously denied, trying to request again\");\r\n      }\r\n    } catch (err) {\r\n      console.log(\"Permissions API not supported:\", err);\r\n    }\r\n    \r\n    // Now force a permission prompt using getUserMedia\r\n    const stream = await navigator.mediaDevices.getUserMedia({ \r\n      video: { \r\n        facingMode: \"user\",\r\n        width: { ideal: 640 },\r\n        height: { ideal: 480 }\r\n      } \r\n    });\r\n    \r\n    // Stop the stream immediately to release camera\r\n    stream.getTracks().forEach(track => track.stop());\r\n    \r\n    // Check permission status again\r\n    if (navigator.permissions && navigator.permissions.query) {\r\n      permissionStatus = await navigator.permissions.query({ name: 'camera' });\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      permissionGranted: true,\r\n      permissionState: permissionStatus?.state || 'granted',\r\n      message: \"Camera permission successfully requested\"\r\n    };\r\n  } catch (err) {\r\n    console.error(\"Error requesting camera permission:\", err);\r\n    return {\r\n      success: false,\r\n      permissionGranted: false,\r\n      error: err.name,\r\n      message: err.message,\r\n      isDenied: err.name === \"NotAllowedError\",\r\n      isNotFound: err.name === \"NotFoundError\"\r\n    };\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}