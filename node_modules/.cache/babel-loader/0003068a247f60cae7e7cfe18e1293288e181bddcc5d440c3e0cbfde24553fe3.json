{"ast":null,"code":"import { ref, set, get, onValue } from \"firebase/database\";\nimport { rtdb } from \"../firebase/config\";\n\n/**\r\n * Direct test to validate Firebase Realtime Database connection\r\n * Run this function from the browser console to debug\r\n */\nexport const testDatabaseConnection = async () => {\n  console.group(\"üîç Firebase Connection Test\");\n  console.log(\"Starting Firebase connection test...\");\n\n  // Step 1: Verify rtdb is initialized\n  if (!rtdb) {\n    console.error(\"‚ùå Firebase Realtime Database is not initialized!\");\n    console.groupEnd();\n    return {\n      success: false,\n      error: \"Database not initialized\"\n    };\n  }\n  console.log(\"‚úì Database reference exists\");\n\n  // Step 2: Check for connection status using .info/connected\n  try {\n    console.log(\"Checking connection status...\");\n    let connectionStatus = false;\n\n    // Create a promise that resolves when we get connection status\n    const connectionPromise = new Promise(resolve => {\n      const connectedRef = ref(rtdb, '.info/connected');\n      const unsubscribe = onValue(connectedRef, snap => {\n        connectionStatus = snap.val() === true;\n        console.log(`Connection status: ${connectionStatus ? '‚úÖ Connected' : '‚ùå Disconnected'}`);\n        unsubscribe();\n        resolve(connectionStatus);\n      });\n\n      // Timeout after 5 seconds\n      setTimeout(() => {\n        unsubscribe();\n        if (!connectionStatus) {\n          console.warn(\"‚ö†Ô∏è Connection check timed out\");\n          resolve(false);\n        }\n      }, 5000);\n    });\n    await connectionPromise;\n    if (!connectionStatus) {\n      console.error(\"‚ùå Not connected to Firebase Realtime Database!\");\n      console.groupEnd();\n      return {\n        success: false,\n        error: \"Not connected to database\"\n      };\n    }\n  } catch (connErr) {\n    console.error(\"‚ùå Error checking connection status:\", connErr);\n  }\n\n  // Step 3: Perform test write and read\n  try {\n    const testData = {\n      timestamp: new Date().toISOString(),\n      message: \"Firebase connection test\",\n      random: Math.random()\n    };\n    const testPath = \"debug/connection_test\";\n    console.log(`Writing test data to ${testPath}...`);\n\n    // Write data\n    await set(ref(rtdb, testPath), testData);\n    console.log(\"‚úÖ Test write successful!\");\n\n    // Read data back\n    console.log(\"Reading test data...\");\n    const snapshot = await get(ref(rtdb, testPath));\n    if (!snapshot.exists()) {\n      console.error(\"‚ùå Test data not found after writing!\");\n      console.groupEnd();\n      return {\n        success: false,\n        error: \"Data not found after writing\"\n      };\n    }\n    const readData = snapshot.val();\n    console.log(\"‚úÖ Read successful:\", readData);\n\n    // Validate that what we wrote matches what we read\n    const isValid = readData.timestamp === testData.timestamp && readData.random === testData.random;\n    if (!isValid) {\n      console.error(\"‚ùå Read data doesn't match written data!\");\n      console.groupEnd();\n      return {\n        success: false,\n        error: \"Data mismatch\"\n      };\n    }\n    console.log(\"üéâ Firebase connection test passed successfully!\");\n    console.groupEnd();\n    return {\n      success: true,\n      data: readData\n    };\n  } catch (error) {\n    console.error(\"‚ùå Firebase test failed:\", error);\n    console.groupEnd();\n    return {\n      success: false,\n      error: error.message,\n      code: error.code,\n      stack: error.stack\n    };\n  }\n};\n\n// Make function available in global window for console debugging\nif (typeof window !== 'undefined') {\n  window.testFirebaseConnection = testDatabaseConnection;\n  console.log(\"üîç Firebase test utility loaded! Run window.testFirebaseConnection() in console\");\n}\nexport default testDatabaseConnection;","map":{"version":3,"names":["ref","set","get","onValue","rtdb","testDatabaseConnection","console","group","log","error","groupEnd","success","connectionStatus","connectionPromise","Promise","resolve","connectedRef","unsubscribe","snap","val","setTimeout","warn","connErr","testData","timestamp","Date","toISOString","message","random","Math","testPath","snapshot","exists","readData","isValid","data","code","stack","window","testFirebaseConnection"],"sources":["D:/Movies/Aniket/test2/test/src/services/testFirebaseConnection.js"],"sourcesContent":["import { ref, set, get, onValue } from \"firebase/database\";\r\nimport { rtdb } from \"../firebase/config\";\r\n\r\n/**\r\n * Direct test to validate Firebase Realtime Database connection\r\n * Run this function from the browser console to debug\r\n */\r\nexport const testDatabaseConnection = async () => {\r\n  console.group(\"üîç Firebase Connection Test\");\r\n  console.log(\"Starting Firebase connection test...\");\r\n  \r\n  // Step 1: Verify rtdb is initialized\r\n  if (!rtdb) {\r\n    console.error(\"‚ùå Firebase Realtime Database is not initialized!\");\r\n    console.groupEnd();\r\n    return { success: false, error: \"Database not initialized\" };\r\n  }\r\n  \r\n  console.log(\"‚úì Database reference exists\");\r\n  \r\n  // Step 2: Check for connection status using .info/connected\r\n  try {\r\n    console.log(\"Checking connection status...\");\r\n    let connectionStatus = false;\r\n    \r\n    // Create a promise that resolves when we get connection status\r\n    const connectionPromise = new Promise((resolve) => {\r\n      const connectedRef = ref(rtdb, '.info/connected');\r\n      const unsubscribe = onValue(connectedRef, (snap) => {\r\n        connectionStatus = snap.val() === true;\r\n        console.log(`Connection status: ${connectionStatus ? '‚úÖ Connected' : '‚ùå Disconnected'}`);\r\n        unsubscribe();\r\n        resolve(connectionStatus);\r\n      });\r\n      \r\n      // Timeout after 5 seconds\r\n      setTimeout(() => {\r\n        unsubscribe();\r\n        if (!connectionStatus) {\r\n          console.warn(\"‚ö†Ô∏è Connection check timed out\");\r\n          resolve(false);\r\n        }\r\n      }, 5000);\r\n    });\r\n    \r\n    await connectionPromise;\r\n    \r\n    if (!connectionStatus) {\r\n      console.error(\"‚ùå Not connected to Firebase Realtime Database!\");\r\n      console.groupEnd();\r\n      return { success: false, error: \"Not connected to database\" };\r\n    }\r\n  } catch (connErr) {\r\n    console.error(\"‚ùå Error checking connection status:\", connErr);\r\n  }\r\n  \r\n  // Step 3: Perform test write and read\r\n  try {\r\n    const testData = {\r\n      timestamp: new Date().toISOString(),\r\n      message: \"Firebase connection test\",\r\n      random: Math.random()\r\n    };\r\n    \r\n    const testPath = \"debug/connection_test\";\r\n    console.log(`Writing test data to ${testPath}...`);\r\n    \r\n    // Write data\r\n    await set(ref(rtdb, testPath), testData);\r\n    console.log(\"‚úÖ Test write successful!\");\r\n    \r\n    // Read data back\r\n    console.log(\"Reading test data...\");\r\n    const snapshot = await get(ref(rtdb, testPath));\r\n    \r\n    if (!snapshot.exists()) {\r\n      console.error(\"‚ùå Test data not found after writing!\");\r\n      console.groupEnd();\r\n      return { success: false, error: \"Data not found after writing\" };\r\n    }\r\n    \r\n    const readData = snapshot.val();\r\n    console.log(\"‚úÖ Read successful:\", readData);\r\n    \r\n    // Validate that what we wrote matches what we read\r\n    const isValid = readData.timestamp === testData.timestamp && \r\n                    readData.random === testData.random;\r\n    \r\n    if (!isValid) {\r\n      console.error(\"‚ùå Read data doesn't match written data!\");\r\n      console.groupEnd();\r\n      return { success: false, error: \"Data mismatch\" };\r\n    }\r\n    \r\n    console.log(\"üéâ Firebase connection test passed successfully!\");\r\n    console.groupEnd();\r\n    return { success: true, data: readData };\r\n    \r\n  } catch (error) {\r\n    console.error(\"‚ùå Firebase test failed:\", error);\r\n    console.groupEnd();\r\n    return { \r\n      success: false, \r\n      error: error.message,\r\n      code: error.code,\r\n      stack: error.stack\r\n    };\r\n  }\r\n};\r\n\r\n// Make function available in global window for console debugging\r\nif (typeof window !== 'undefined') {\r\n  window.testFirebaseConnection = testDatabaseConnection;\r\n  console.log(\"üîç Firebase test utility loaded! Run window.testFirebaseConnection() in console\");\r\n}\r\n\r\nexport default testDatabaseConnection;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}