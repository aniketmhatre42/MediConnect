{"ast":null,"code":"import { ref, push, set, get, query, orderByChild, equalTo, update } from \"firebase/database\";\nimport { rtdb } from \"../firebase/config\";\n\n/**\r\n * Service for managing prescription notifications between ASHA workers and users\r\n */\nconst notificationService = {\n  /**\r\n   * Create a prescription notification for a user\r\n   * \r\n   * @param {Object} notificationData - The notification data\r\n   * @returns {Promise<string>} - The notification ID\r\n   */\n  async createPrescriptionNotification(notificationData) {\n    try {\n      // Create reference for the new notification\n      const notificationsRef = ref(rtdb, 'prescriptionNotifications');\n      const newNotificationRef = push(notificationsRef);\n\n      // Add timestamp\n      const notificationWithTimestamp = {\n        ...notificationData,\n        createdAt: new Date().toISOString(),\n        read: false\n      };\n\n      // Save notification\n      await set(newNotificationRef, notificationWithTimestamp);\n      return newNotificationRef.key;\n    } catch (error) {\n      console.error(\"Error creating prescription notification:\", error);\n      throw error;\n    }\n  },\n  /**\r\n   * Get all notifications for a specific user\r\n   * \r\n   * @param {string} userId - The user ID\r\n   * @returns {Promise<Array>} - Array of notifications\r\n   */\n  async getUserNotifications(userId) {\n    try {\n      if (!userId) {\n        console.error(\"No user ID provided for fetching notifications\");\n        return [];\n      }\n      console.log(\"Fetching notifications for user:\", userId);\n      const notificationsRef = ref(rtdb, 'prescriptionNotifications');\n\n      // Get all notifications first to debug\n      const allSnapshot = await get(notificationsRef);\n      if (allSnapshot.exists()) {\n        console.log(\"Total notifications in DB:\", Object.keys(allSnapshot.val()).length);\n      } else {\n        console.log(\"No notifications found in DB\");\n      }\n\n      // Query notifications by userId\n      const userNotificationsQuery = query(notificationsRef, orderByChild('userId'), equalTo(userId));\n      const snapshot = await get(userNotificationsQuery);\n      if (!snapshot.exists()) {\n        console.log(`No notifications found for user: ${userId}`);\n        return [];\n      }\n\n      // Convert to array and add ID\n      const notifications = [];\n      snapshot.forEach(childSnapshot => {\n        notifications.push({\n          id: childSnapshot.key,\n          ...childSnapshot.val()\n        });\n      });\n      console.log(`Found ${notifications.length} notifications for user:`, userId);\n\n      // Sort by created date (newest first)\n      return notifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\n    } catch (error) {\n      console.error(\"Error fetching user notifications:\", error);\n      return [];\n    }\n  },\n  /**\r\n   * Mark a notification as read\r\n   * \r\n   * @param {string} notificationId - The notification ID\r\n   * @returns {Promise<void>}\r\n   */\n  async markNotificationAsRead(notificationId) {\n    try {\n      const notificationRef = ref(rtdb, `prescriptionNotifications/${notificationId}`);\n\n      // Check if notification exists\n      const snapshot = await get(notificationRef);\n      if (!snapshot.exists()) {\n        console.error(\"Notification not found:\", notificationId);\n        return;\n      }\n\n      // Update the read status\n      await update(notificationRef, {\n        read: true\n      });\n      console.log(\"Notification marked as read:\", notificationId);\n    } catch (error) {\n      console.error(\"Error marking notification as read:\", error);\n      throw error;\n    }\n  },\n  /**\r\n   * Generate a random estimate for billing and delivery\r\n   * For demo purposes only\r\n   * \r\n   * @returns {Object} - Random estimates for billing and delivery\r\n   */\n  generateRandomEstimates() {\n    // Random delivery time between 30-120 minutes\n    const deliveryMinutes = Math.floor(Math.random() * 90) + 30;\n\n    // Random cost between 100-500 rupees\n    const medicationCost = Math.floor(Math.random() * 400) + 100;\n\n    // Random delivery fee between 20-50 rupees\n    const deliveryFee = Math.floor(Math.random() * 30) + 20;\n    const total = medicationCost + deliveryFee;\n    return {\n      deliveryTime: `${deliveryMinutes} minutes`,\n      deliveryEstimate: new Date(Date.now() + deliveryMinutes * 60000).toISOString(),\n      billing: {\n        medicationCost: medicationCost,\n        deliveryFee: deliveryFee,\n        total: total,\n        currency: \"INR\"\n      }\n    };\n  }\n};\nexport default notificationService;","map":{"version":3,"names":["ref","push","set","get","query","orderByChild","equalTo","update","rtdb","notificationService","createPrescriptionNotification","notificationData","notificationsRef","newNotificationRef","notificationWithTimestamp","createdAt","Date","toISOString","read","key","error","console","getUserNotifications","userId","log","allSnapshot","exists","Object","keys","val","length","userNotificationsQuery","snapshot","notifications","forEach","childSnapshot","id","sort","a","b","markNotificationAsRead","notificationId","notificationRef","generateRandomEstimates","deliveryMinutes","Math","floor","random","medicationCost","deliveryFee","total","deliveryTime","deliveryEstimate","now","billing","currency"],"sources":["D:/Movies/Aniket/test2/test/src/services/notificationService.js"],"sourcesContent":["import { ref, push, set, get, query, orderByChild, equalTo, update } from \"firebase/database\";\r\nimport { rtdb } from \"../firebase/config\";\r\n\r\n/**\r\n * Service for managing prescription notifications between ASHA workers and users\r\n */\r\nconst notificationService = {\r\n  /**\r\n   * Create a prescription notification for a user\r\n   * \r\n   * @param {Object} notificationData - The notification data\r\n   * @returns {Promise<string>} - The notification ID\r\n   */\r\n  async createPrescriptionNotification(notificationData) {\r\n    try {\r\n      // Create reference for the new notification\r\n      const notificationsRef = ref(rtdb, 'prescriptionNotifications');\r\n      const newNotificationRef = push(notificationsRef);\r\n      \r\n      // Add timestamp\r\n      const notificationWithTimestamp = {\r\n        ...notificationData,\r\n        createdAt: new Date().toISOString(),\r\n        read: false\r\n      };\r\n      \r\n      // Save notification\r\n      await set(newNotificationRef, notificationWithTimestamp);\r\n      \r\n      return newNotificationRef.key;\r\n    } catch (error) {\r\n      console.error(\"Error creating prescription notification:\", error);\r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Get all notifications for a specific user\r\n   * \r\n   * @param {string} userId - The user ID\r\n   * @returns {Promise<Array>} - Array of notifications\r\n   */\r\n  async getUserNotifications(userId) {\r\n    try {\r\n      if (!userId) {\r\n        console.error(\"No user ID provided for fetching notifications\");\r\n        return [];\r\n      }\r\n\r\n      console.log(\"Fetching notifications for user:\", userId);\r\n      const notificationsRef = ref(rtdb, 'prescriptionNotifications');\r\n      \r\n      // Get all notifications first to debug\r\n      const allSnapshot = await get(notificationsRef);\r\n      if (allSnapshot.exists()) {\r\n        console.log(\"Total notifications in DB:\", Object.keys(allSnapshot.val()).length);\r\n      } else {\r\n        console.log(\"No notifications found in DB\");\r\n      }\r\n      \r\n      // Query notifications by userId\r\n      const userNotificationsQuery = query(\r\n        notificationsRef, \r\n        orderByChild('userId'),\r\n        equalTo(userId)\r\n      );\r\n      \r\n      const snapshot = await get(userNotificationsQuery);\r\n      \r\n      if (!snapshot.exists()) {\r\n        console.log(`No notifications found for user: ${userId}`);\r\n        return [];\r\n      }\r\n      \r\n      // Convert to array and add ID\r\n      const notifications = [];\r\n      snapshot.forEach(childSnapshot => {\r\n        notifications.push({\r\n          id: childSnapshot.key,\r\n          ...childSnapshot.val()\r\n        });\r\n      });\r\n      \r\n      console.log(`Found ${notifications.length} notifications for user:`, userId);\r\n      \r\n      // Sort by created date (newest first)\r\n      return notifications.sort((a, b) => \r\n        new Date(b.createdAt) - new Date(a.createdAt)\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Error fetching user notifications:\", error);\r\n      return [];\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Mark a notification as read\r\n   * \r\n   * @param {string} notificationId - The notification ID\r\n   * @returns {Promise<void>}\r\n   */\r\n  async markNotificationAsRead(notificationId) {\r\n    try {\r\n      const notificationRef = ref(rtdb, `prescriptionNotifications/${notificationId}`);\r\n      \r\n      // Check if notification exists\r\n      const snapshot = await get(notificationRef);\r\n      if (!snapshot.exists()) {\r\n        console.error(\"Notification not found:\", notificationId);\r\n        return;\r\n      }\r\n      \r\n      // Update the read status\r\n      await update(notificationRef, { read: true });\r\n      console.log(\"Notification marked as read:\", notificationId);\r\n    } catch (error) {\r\n      console.error(\"Error marking notification as read:\", error);\r\n      throw error;\r\n    }\r\n  },\r\n  \r\n  /**\r\n   * Generate a random estimate for billing and delivery\r\n   * For demo purposes only\r\n   * \r\n   * @returns {Object} - Random estimates for billing and delivery\r\n   */\r\n  generateRandomEstimates() {\r\n    // Random delivery time between 30-120 minutes\r\n    const deliveryMinutes = Math.floor(Math.random() * 90) + 30;\r\n    \r\n    // Random cost between 100-500 rupees\r\n    const medicationCost = Math.floor(Math.random() * 400) + 100;\r\n    \r\n    // Random delivery fee between 20-50 rupees\r\n    const deliveryFee = Math.floor(Math.random() * 30) + 20;\r\n    \r\n    const total = medicationCost + deliveryFee;\r\n    \r\n    return {\r\n      deliveryTime: `${deliveryMinutes} minutes`,\r\n      deliveryEstimate: new Date(Date.now() + deliveryMinutes * 60000).toISOString(),\r\n      billing: {\r\n        medicationCost: medicationCost,\r\n        deliveryFee: deliveryFee,\r\n        total: total,\r\n        currency: \"INR\"\r\n      }\r\n    };\r\n  }\r\n};\r\n\r\nexport default notificationService;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}