{"ast":null,"code":"import { saveAs } from 'file-saver';\n\n// Base directory for storing face data\nconst FACE_DATA_DIR = 'face_data';\n\n/**\r\n * Saves face descriptor data to a local file in the user's download directory\r\n * @param {string} userId - The unique user ID\r\n * @param {Float32Array} descriptor - The face descriptor data\r\n * @returns {Promise<boolean>} - Whether the save was successful\r\n */\nexport const saveFaceDescriptor = async (userId, descriptor) => {\n  try {\n    console.log(`Saving face descriptor for user ${userId}`);\n\n    // Convert descriptor to regular array for JSON serialization\n    const descriptorArray = Array.from(descriptor);\n    const faceData = {\n      userId,\n      descriptor: descriptorArray,\n      timestamp: new Date().toISOString()\n    };\n\n    // Create a Blob with the JSON data\n    const blob = new Blob([JSON.stringify(faceData, null, 2)], {\n      type: 'application/json'\n    });\n\n    // Save the file using FileSaver.js\n    const filename = `${FACE_DATA_DIR}_${userId}.json`;\n    saveAs(blob, filename);\n\n    // Also keep a copy in localStorage for immediate use\n    storeLocalCopy(userId, descriptorArray);\n    console.log(`Face descriptor saved to file: ${filename}`);\n    return true;\n  } catch (error) {\n    console.error('Error saving face descriptor to file:', error);\n    return false;\n  }\n};\n\n/**\r\n * Loads face descriptor data from localStorage (as files can't be directly accessed)\r\n * @param {string} userId - The unique user ID\r\n * @returns {Float32Array|null} - The face descriptor or null if not found\r\n */\nexport const loadFaceDescriptor = userId => {\n  try {\n    // Local storage is used as a cache since we can't directly read files\n    const localCopy = getLocalCopy(userId);\n    if (localCopy) {\n      return new Float32Array(localCopy);\n    }\n    return null;\n  } catch (error) {\n    console.error('Error loading face descriptor:', error);\n    return null;\n  }\n};\n\n/**\r\n * Stores a local copy of the face data in localStorage for immediate use\r\n * @param {string} userId - The unique user ID\r\n * @param {Array} descriptorArray - The face descriptor array\r\n */\nconst storeLocalCopy = (userId, descriptorArray) => {\n  try {\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\n\n    // Check if this user already has a descriptor\n    const existingIndex = faceDescriptors.findIndex(item => item.userId === userId);\n    if (existingIndex >= 0) {\n      faceDescriptors[existingIndex].descriptor = descriptorArray;\n    } else {\n      faceDescriptors.push({\n        userId,\n        descriptor: descriptorArray,\n        timestamp: new Date().toISOString()\n      });\n    }\n    localStorage.setItem('face_descriptors', JSON.stringify(faceDescriptors));\n  } catch (e) {\n    console.error('Error storing local copy of face data:', e);\n  }\n};\n\n/**\r\n * Gets a local copy of the face descriptor from localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Array|null} - The descriptor array or null if not found\r\n */\nconst getLocalCopy = userId => {\n  try {\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\n    const userFace = faceDescriptors.find(item => item.userId === userId);\n    return userFace ? userFace.descriptor : null;\n  } catch (e) {\n    console.error('Error getting local copy of face data:', e);\n    return null;\n  }\n};\n\n/**\r\n * Removes a face descriptor from both file and localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {boolean} - Whether the removal was successful\r\n */\nexport const removeFaceDescriptor = userId => {\n  try {\n    // Remove from localStorage\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\n    const filteredDescriptors = faceDescriptors.filter(item => item.userId !== userId);\n    localStorage.setItem('face_descriptors', JSON.stringify(filteredDescriptors));\n    console.log(`Face descriptor for user ${userId} removed from local storage`);\n    console.log(`Note: The saved file ${FACE_DATA_DIR}_${userId}.json must be deleted manually`);\n    return true;\n  } catch (error) {\n    console.error('Error removing face descriptor:', error);\n    return false;\n  }\n};\n\n/**\r\n * Lists all user IDs with stored face descriptors in localStorage\r\n * @returns {Array<string>} - Array of user IDs\r\n */\nexport const listFaceUsers = () => {\n  try {\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\n    return faceDescriptors.map(item => item.userId);\n  } catch (error) {\n    console.error('Error listing face users:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["saveAs","FACE_DATA_DIR","saveFaceDescriptor","userId","descriptor","console","log","descriptorArray","Array","from","faceData","timestamp","Date","toISOString","blob","Blob","JSON","stringify","type","filename","storeLocalCopy","error","loadFaceDescriptor","localCopy","getLocalCopy","Float32Array","faceDescriptors","parse","localStorage","getItem","existingIndex","findIndex","item","push","setItem","e","userFace","find","removeFaceDescriptor","filteredDescriptors","filter","listFaceUsers","map"],"sources":["D:/Movies/Aniket/test2/test/src/services/localFaceStorage.js"],"sourcesContent":["import { saveAs } from 'file-saver';\r\n\r\n// Base directory for storing face data\r\nconst FACE_DATA_DIR = 'face_data';\r\n\r\n/**\r\n * Saves face descriptor data to a local file in the user's download directory\r\n * @param {string} userId - The unique user ID\r\n * @param {Float32Array} descriptor - The face descriptor data\r\n * @returns {Promise<boolean>} - Whether the save was successful\r\n */\r\nexport const saveFaceDescriptor = async (userId, descriptor) => {\r\n  try {\r\n    console.log(`Saving face descriptor for user ${userId}`);\r\n    \r\n    // Convert descriptor to regular array for JSON serialization\r\n    const descriptorArray = Array.from(descriptor);\r\n    \r\n    const faceData = {\r\n      userId,\r\n      descriptor: descriptorArray,\r\n      timestamp: new Date().toISOString()\r\n    };\r\n    \r\n    // Create a Blob with the JSON data\r\n    const blob = new Blob([JSON.stringify(faceData, null, 2)], {\r\n      type: 'application/json'\r\n    });\r\n    \r\n    // Save the file using FileSaver.js\r\n    const filename = `${FACE_DATA_DIR}_${userId}.json`;\r\n    saveAs(blob, filename);\r\n    \r\n    // Also keep a copy in localStorage for immediate use\r\n    storeLocalCopy(userId, descriptorArray);\r\n    \r\n    console.log(`Face descriptor saved to file: ${filename}`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving face descriptor to file:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Loads face descriptor data from localStorage (as files can't be directly accessed)\r\n * @param {string} userId - The unique user ID\r\n * @returns {Float32Array|null} - The face descriptor or null if not found\r\n */\r\nexport const loadFaceDescriptor = (userId) => {\r\n  try {\r\n    // Local storage is used as a cache since we can't directly read files\r\n    const localCopy = getLocalCopy(userId);\r\n    if (localCopy) {\r\n      return new Float32Array(localCopy);\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    console.error('Error loading face descriptor:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stores a local copy of the face data in localStorage for immediate use\r\n * @param {string} userId - The unique user ID\r\n * @param {Array} descriptorArray - The face descriptor array\r\n */\r\nconst storeLocalCopy = (userId, descriptorArray) => {\r\n  try {\r\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\r\n    \r\n    // Check if this user already has a descriptor\r\n    const existingIndex = faceDescriptors.findIndex(item => item.userId === userId);\r\n    \r\n    if (existingIndex >= 0) {\r\n      faceDescriptors[existingIndex].descriptor = descriptorArray;\r\n    } else {\r\n      faceDescriptors.push({\r\n        userId,\r\n        descriptor: descriptorArray,\r\n        timestamp: new Date().toISOString()\r\n      });\r\n    }\r\n    \r\n    localStorage.setItem('face_descriptors', JSON.stringify(faceDescriptors));\r\n  } catch (e) {\r\n    console.error('Error storing local copy of face data:', e);\r\n  }\r\n};\r\n\r\n/**\r\n * Gets a local copy of the face descriptor from localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {Array|null} - The descriptor array or null if not found\r\n */\r\nconst getLocalCopy = (userId) => {\r\n  try {\r\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\r\n    const userFace = faceDescriptors.find(item => item.userId === userId);\r\n    return userFace ? userFace.descriptor : null;\r\n  } catch (e) {\r\n    console.error('Error getting local copy of face data:', e);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Removes a face descriptor from both file and localStorage\r\n * @param {string} userId - The unique user ID\r\n * @returns {boolean} - Whether the removal was successful\r\n */\r\nexport const removeFaceDescriptor = (userId) => {\r\n  try {\r\n    // Remove from localStorage\r\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\r\n    const filteredDescriptors = faceDescriptors.filter(item => item.userId !== userId);\r\n    localStorage.setItem('face_descriptors', JSON.stringify(filteredDescriptors));\r\n    \r\n    console.log(`Face descriptor for user ${userId} removed from local storage`);\r\n    console.log(`Note: The saved file ${FACE_DATA_DIR}_${userId}.json must be deleted manually`);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error removing face descriptor:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Lists all user IDs with stored face descriptors in localStorage\r\n * @returns {Array<string>} - Array of user IDs\r\n */\r\nexport const listFaceUsers = () => {\r\n  try {\r\n    const faceDescriptors = JSON.parse(localStorage.getItem('face_descriptors') || '[]');\r\n    return faceDescriptors.map(item => item.userId);\r\n  } catch (error) {\r\n    console.error('Error listing face users:', error);\r\n    return [];\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}